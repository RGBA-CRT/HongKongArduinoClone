'ファーム制御系

Function GetComBaudrate(hSerial AS HANDLE) AS DWord
	Dim dcb As DCB_SETTING
	GetCommState(hSerial,dcb)
	GetComBaudrate=dcb.BaudRate
End Function

Function SetComTimeOut(hSerialPort AS HANDLE,TimeOut AS DWord) AS Byte
	Dim ct AS COMMTIMEOUTS
	ct.ReadIntervalTimeout=TimeOut		'連続受信タイムアウト
	ct.ReadTotalTimeoutConstant=TimeOut	'Constant+Multiplier*バイト数＝タイムアウト
	ct.ReadTotalTimeoutMultiplier=20
	ct.WriteTotalTimeoutConstant=TimeOut
	ct.WriteTotalTimeoutMultiplier=20

	SetCommTimeouts(hSerialPort,VarPtr(ct))
EndFunction

Sub ChangeComBaudrate(hSerial AS HANDLE,rate AS DWord)
	Dim dcb As DCB_SETTING
	GetCommState(hSerial,dcb)
	dcb.BaudRate = rate		'転送速度の指定
	SetCommState(hSerial,dcb)

	FlushCom(hSerial)

	GetCommState(hSerial,dcb)
End Sub

Sub ChangeBaudrate(hSerial AS HANDLE,rate AS DWord)
	'Arduinoレート変更コマンド送信
	Dim cmd[5] AS Byte,dwAB AS DWord
	cmd[0]=Asc("b")
	memcpy(cmd+1,VarPtr(rate),4)

	if WriteFile(hSerial,cmd,5,VarPtr(dwAB),ByVal NULL)=FALSE or dwAB<>5 Then DBM("BC_ERR "+Str$(GetLastError()))
	FlushFileBuffers(hSerial)
	FlushCom(hSerial)

	'PC側レート変更
	ChangeComBaudrate(hSerial,rate)
End Sub

Function OpenComPort(PortName AS BytePtr,rate AS DWord)(inBuffer As DWord,outBuffer AS DWord) AS HANDLE
	Dim hSerial As HANDLE
	Dim dcb As DCB_SETTING

	if rate=0 Then rate=DEFAULT_BAUDRATE
	
	Dim portPath As BytePtr
	portPath=calloc(lstrlen(PortName)+6)
	wsprintf(portPath,"\\.\%s",PortName)

	hSerial=CreateFile(portPath,GENERIC_READ Or GENERIC_WRITE,NULL,ByVal NULL,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL)
	free(portPath):portPath=NULL
	if hSerial=INVALID_HANDLE_VALUE  Then OpenComPort=NULL AS VoidPtr :ExitFunction

	'バッファ設定
	if inBuffer=0 Then	inBuffer=1024*10
	if outBuffer=0 Then	outBuffer=1024*10
	if SetupComm(hSerial,inBuffer,outBuffer)=0 Then
		outBuffer=GetLastError()
		DBM("Init com error")
		debug
	End If

	FlushCom(hSerial)

	dcb.BaudRate = rate		'転送速度の指定
	dcb.ByteSize = 8		'ビット長の指定
	dcb.fBitFields = TRUE	'バイナリモードのフラグを有効にし
	dcb.Parity = 0			'パリティの設定（パリティなし）
	dcb.StopBits = 0		'ストップビット数を指定(1ビット)
	SetCommState(hSerial,dcb)

	'通信タイムアウトの設定
	SetComTimeOut(hSerial,1000)

'	DBM("baudrate="+Str$(rate)+"bps")
	
	OpenComPort=hSerial
EndFunction

'RST OE WE CS などを制御
Sub SendControl(hSerial AS HANDLE,b AS Byte)
	Dim cmd[1] AS Byte,dwAB AS DWord
	cmd[0]=Asc("c")
	cmd[1]=b
	if WriteFile(hSerial,cmd,2,VarPtr(dwAB),ByVal NULL)=FALSE or dwAB<>2 Then DBM("CTL_ERR "+Str$(GetLastError()))
EndSub

'アドレスセット
Sub SetAddress(hSerial AS HANDLE,address AS DWord, isLoROM AS Byte)
	Dim cmd[7] AS Byte
	Dim ReadByte As DWord
	Dim dwReadByte As DWord

	'[0]コマンド
	if isLoROM Then
		cmd[0]=Asc("a")
	Else
		cmd[0]=Asc("A")
	Endif

	'[1-3] アドレス(ビッグエンディアン)
	cmd[1] = (address >>  0) AS Byte
	cmd[2] = (address >>  8) AS Byte
	cmd[3] = (address >> 16) AS Byte

	WriteFile(hSerial,cmd,4,VarPtr(dwReadByte),ByVal NULL)
EndSub

'カートリッジからのデータ受信(ROMだけでなくカートリッジ上のメモリ空間も対象)
'コントロールバスはいじらないので手動でやる必要あり
Function ReadROM(hSerial AS HANDLE,data AS BytePtr, offset AS Long,address AS DWord, size AS Long, isLoROM AS BOOL) As Long
	Dim cmd[7] AS Byte
	Dim ReadByte As DWord
	Dim dwReadByte As DWord

	if isLoROM Then
		cmd[0]=Asc("r")	'LoROM	
	Else
		cmd[0]=Asc("R")	'HiROM
	Endif

	cmd[1] = (address >>  0) AS Byte
	cmd[2] = (address >>  8) AS Byte
	cmd[3] = (address >> 16) AS Byte

	cmd[4] = (size >>   0) AS Byte
	cmd[5] = (size >>   8) AS Byte

	if size>&HFFFF Then debug

	WriteFile(hSerial,cmd,6,VarPtr(dwReadByte),ByVal NULL)
	dwReadByte=0

	'デフォルトのリトライ回数(=タイムアウトのms)
	'TIMEOUT = 転送時間（理論値）× 10 + 10
	Dim HKAC_HW_RETRY As DWord
	HKAC_HW_RETRY = (size / (GetComBaudrate(hSerial)/8))*1000 * HKAC_TRANSFER_FLOAT_TIME_MUL +10
	printf(ex"理論転送時間：%dms\t",(HKAC_HW_RETRY/HKAC_TRANSFER_FLOAT_TIME_MUL) As DWord)

	Dim dwErrors AS DWord,retry AS DWord
	Dim cs AS COMSTAT

	Do		
		if retry>HKAC_HW_RETRY or GetCancelKey() And &H80 Then ExitDo

		ClearCommError(hSerial,VarPtr(dwErrors),cs)
		if cs.cbInQue=0 Then 
			retry++
			if retry Mod 100 Then Sleep(1)
			Continue
		End If

		if ReadFile(hSerial,(data)+offset + ReadByte, cs.cbInQue,VarPtr(dwReadByte),ByVal NULL) = FALSE Then DBM(ex"\r\n[Connection Error!] GLE:"+Str$(GetLastError())):ExitDo
		ReadByte+=dwReadByte
	
		if ReadByte >= size Then exitdo
	Loop

	printf(ex"%03X:%X/%X bytes recived %d/%d\n",address,ReadByte,size,retry,HKAC_HW_RETRY)

	ReadROM=ReadByte
EndFunction

Function WaitForRequest(hSerial AS HANDLE,requestChar AS Byte,timedOut_ms AS DWord) AS BOOL
	Dim dwErrors AS DWord,retry AS DWord,rsv AS Byte
	Dim cs AS COMSTAT,readLen AS DWord
	
	Do
		ClearCommError(hSerial,VarPtr(dwErrors),cs)
		if cs.cbInQue=0 Then 
			retry++
			if retry>timedOut_ms Then WaitForRequest=FALSE:ExitDo
			readLen=0
		Else
			readLen=1
		End If

		ReadFile(hSerial,VarPtr(rsv),readLen ,VarPtr(dwErrors),ByVal NULL)
		if rsv=requestChar Then 
			WaitForRequest=TRUE
			ExitDo
		Else
			printf("[WaitRequest]Invailed Request : %X[%c]",rsv,rsv)
		End If
		Sleep(1)
		retry++
		if retry<timedOut_ms Then Continue
	Loop

	if retry>10 Then
		printf(ex"[WaitRequest] wait:%d ms ok:%d\n",retry,WaitForRequest)
	End If
End Function

'カートリッジへの出力データ送信(ROMだけでなくカートリッジ上のメモリ空間も対象)
'コントロールバスはいじらないので手動でやる必要あり
Function WriteROM(hSerial AS HANDLE,data AS BytePtr, offset AS Long,address AS DWord, size AS Long, isLoROM AS BOOL) As Long
	Dim cmd[7] AS Byte
	Dim WriteCount As DWord
	Dim dwWD As DWord

	if isLoROM Then
		cmd[0]=Asc("w")
	Else
		cmd[0]=Asc("W")
	Endif

	cmd[1] = (address >>  0) AS Byte
	cmd[2] = (address >>  8) AS Byte
	cmd[3] = (address >> 16) AS Byte

	cmd[4] = (size >>   0) AS Byte
	cmd[5] = (size >>   8) AS Byte
'	cmd[6] = (size >>  16) AS Byte

	WriteFile(hSerial,cmd,6,VarPtr(dwWD),ByVal NULL)
	Sleep(10)

	WriteCount=0


	Do
		if WaitForRequest(hSerial,Asc("R"),1000) = FALSE Then ExitDo
		WriteFile(hSerial, data+WriteCount , HKAC_WRITE_BUFFER_LEN ,VarPtr(dwWD),ByVal NULL)

		WriteCount+=dwWD
		if WriteCount => size Then exitdo
		if dwWD=0 Then debug
	Loop
	
	WriteROM=WriteCount
	
	if WaitForRequest(hSerial,Asc("E"),1000) = FALSE Then 
		DBM("[DBG]Firmware Error!")
		DBM("書込ルーチン暴走中")
	EndIf
EndFunction

Enum HKAC_CLOCK_STATE
	HKAC_CLOCK_NORMAL  		 = &H35,
	HKAC_CLOCK_CPU_ENABLED   = &H37,
	HKAC_CLOCK_CPU_OVERCLOCKED = &H3f,
	HKAC_CLOCK_DISABLED      = &H30
End Enum

Sub SetCPU_Clock(hSerial AS HANDLE,flag AS HKAC_CLOCK_STATE)
	Dim dwWB AS DWord
	Dim cmd[1] AS Byte

	cmd[0]=Asc("g")
	cmd[1]=flag

	WriteFile(hSerial,cmd, 2,VarPtr(dwWB) , ByVal NULL)

	ReadFile(hSerial,cmd,1,VarPtr(dwWB),ByVal NULL)
	
	printf(ex"ClockOutput: %d, %d, %d, oc:%d ret:%X dwAB:%d\n",(flag And 1),(flag And 2)>>1,(flag And 4)>>2,(flag And 8)>>3,cmd[0],dwWB)
End Sub


Function hasClockModule(hSerial AS HANDLE) AS BOOL
	Dim dwWB AS DWord
	Dim cmd[1] AS Byte

	cmd[0]=Asc("G")

	WriteFile(hSerial,cmd, 2,VarPtr(dwWB) , ByVal NULL)

	ReadFile(hSerial,cmd,1,VarPtr(dwWB),ByVal NULL)
	if cmd[0]=&H31 Then
		hasClockModule=TRUE
	Else
		hasClockModule=FALSE
	End If
End Function

'Arduinoに書かれているファームをチェック(別のスケッチか識別)
'msgをFALSEにするとsilentモード
Function CheckFirmware(hSerial AS HANDLE,msg As BOOL) AS BOOL
	Dim cmd[2] AS Byte,rsv[10] As byte,FwVer AS Byte,retry AS Long
	Dim dwWD As DWord
	Dim cs AS COMSTAT
	cmd[0] = Asc("v")
*SEND_VER_CHECK
	if WriteFile(hSerial,cmd,1,VarPtr(dwWD),ByVal NULL)=FALSE Then ExitFunction
	if ReadFile(hSerial,rsv, 5 ,VarPtr(dwWD),ByVal NULL)=FALSE Then ExitFunction

	FwVer=rsv[4]
	rsv[4]=0

	if lstrcmp(rsv,FIRMWARE_ID)=0 Then 
		if FwVer=FIRMWARE_VERSION Then
			CheckFirmware=TRUE

		Elseif FwVer<FIRMWARE_VERSION Then
			if msg=FALSE Then CheckFirmware=FALSE:ExitFunction
			if MessageBox(hMainWnd,ex"ファームウェアバージョンが不一致です\nファームウェアアップデートをしてください。\nArduino : ver "+Chr$(FwVer)+ex"\nRequest : ver "+Chr$(FIRMWARE_VERSION)+ex"\n\n続行しますか？","FirmwareVersion mismatch",MB_YESNO or MB_ICONWARNING) = IDYES Then
				CheckFirmware=TRUE
			Else
				CheckFirmware=FALSE
			End If
		Else
			Const HKAF_FC2_ERRMES=ex"高いバージョンのファームウェアが検出されました。\r\nこのプログラムを最新版に更新してください。\r\n"
			if msg=TRUE Then MessageBox(hMainWnd,HKAF_FC2_ERRMES,"情報",MB_ICONINFORMATION)
			DBM(HKAF_FC2_ERRMES)
			CheckFirmware=TRUE
		End If
	Else
		if retry>5 Then
			if msg=TRUE Then MessageBox(hMainWnd,ex"接続に失敗しました。デバイスからの応答が不正です。\nCOMポート番号　通信レート Arduinoのスケッチなどを確認してください。\n\n正しい場合は、再試行してください。","Firmware mismatch",MB_ICONERROR)
			DBM("VerCheck Failed.")
			CheckFirmware=FALSE
		Else
			retry++	
			DBM("VerCheck retry...")
			PumpMessage()

			if GetKeyState(VK_ESCAPE) And &H80 Then
				DBM("cancel")
				CheckFirmware=FALSE
			Else
				FlushCom(hSerial)
				Goto *SEND_VER_CHECK
			End If
		End If
	End If
	
	if msg=TRUE Then 
		DBMN("FirmwareID : ") 
		DBM(rsv) 
	End If
End Function

Sub FlushCom(hSerial AS HANDLE)
	PurgeComm(hSerial,PURGE_TXABORT)
	PurgeComm(hSerial,PURGE_RXABORT)

	Dim cs AS COMSTAT,dwErrors AS DWord
	ClearCommError(hSerial,VarPtr(dwErrors),cs)

	'理由はわからないがこのSleepを外すとファームチェックに失敗する
	Sleep(10)

	if cs.cbInQue=0 Then ExitSub

	'受信バッファを全部取り出す
	Dim tmp aS BytePtr
	tmp=calloc(cs.cbInQue)
	LoadFile(hSerial,tmp,cs.cbInQue)
'	printf(ex"ゴミ(%d bytes)：\n",cs.cbInQue)
'	Dump(tmp,cs.cbInQue)
'	printf(ex"%d bytes\n",cs.cbInQue)

	free(tmp): tmp=NULL

	FlushFileBuffers(hSerial)

End Sub


Sub SetCartRegister(bank AS Byte,address AS Word,val AS Byte)(isLoROM AS BOOL)
	Dim cmd[5] AS Byte,dwAB AS DWord,retry AS BOOL

	if isLoROM Then
		cmd[0]=Asc("t")
	Else
		cmd[0]=Asc("T")
	End If
	cmd[1] = bank
	cmd[2] = (address >>  0) AS Byte
	cmd[3] = (address >>  8) AS Byte

	cmd[4] = val

	WriteFile(hCOM,cmd,5,VarPtr(dwAB),ByVal NULL)
	printf(ex"[CMD]%02X%04X = %X\n",bank,address,val)
End Sub

