'-----------------------------------------------------------------------------
'  イベント プロシージャ
'-----------------------------------------------------------------------------
' このファイルには、ウィンドウ [MainWnd] に関するイベントをコーディングします。
' ウィンドウ ハンドル: hMainWnd

' TODO: この位置にグローバルな変数、構造体、定数、関数を定義します。

Dim hCOM As HANDLE
Dim DlgStatus As DLG_STATUS
Dim fWindowActive AS BOOL


'ダイアログの状態
Enum DLG_STATUS
	STATUS_CONNECTED
	STATUS_DUMPING
	STATUS_CLOSED
End Enum

'-----------------------------------------------------------------------------
' ウィンドウメッセージを処理するためのコールバック関数

Function MainWndProc(hWnd As HWND, dwMsg As DWord, wParam As WPARAM, lParam As LPARAM) As DWord
	' TODO: この位置にウィンドウメッセージを処理するためのコードを記述します。

	'デバイス切断接続メッセージ
	if dwMsg=WM_DEVICECHANGE Then
		if DlgStatus=STATUS_CLOSED Then
			'接続されていなかったら
			ListUpComPort(GetDlgItem(hMainWnd,ComList))

		Else if DlgStatus=STATUS_CONNECTED Then
			'Arduinoが抜けてないかチェック
			if CheckFirmware(hCOM,FALSE)=FALSE Then
				DisconnectDevice()
				DBM("Device disconnected.")
			Endif
		
		End If
	Else if dwMsg=WM_COMMAND then
		'アクセラレータキー経由だと、ActiveBasicのEventCallに引っかからないので、アクセラレータフラグを消す
		'printf(ex"WM_COMMAND nofty=%X %X\n",wParam>>16,lParam)
		if lParam=NULL Then wParam = wParam And &HFFFeFFFF

		'タブストップの処理（手動）
		if wParam=ID_DLG_TAB Then  
			SetFocus( GetNextDlgTabItem(hMainWnd,  GetFocus(), FALSE))
			ExitFunction
		End If
	End If
	' イベントプロシージャの呼び出しを行います。
	MainWndProc=EventCall_MainWnd(hWnd,dwMsg,wParam,lParam)
End Function

'-----------------------------------------------------------------------------
' ここから下は、イベントプロシージャを記述するための領域になります。
Function MWnd(DlgItem As Long) As HWND
	MWnd=GetDlgItem(hMainWnd,DlgItem)
EndFunction

Sub MainWnd_Destroy()
	if hCOM<>0 Then CloseHandle(hCOM)

	HongKongArduinoClone_DestroyObjects()
	PostQuitMessage(0)
End Sub

Sub ResetDBM()
	SetWindowText(MWnd(EditBox1),"")
	DBM(ProgramName+" "+VerStr+ex"\r\nProgrammed by RGBA_CRT 2018\r\nThis program was cloned \r\n    from WinHongKongArduino.\r\nCopyright (c) 2014 たにやま\r\n")
End Sub

Sub MainWnd_Create(ByRef CreateStruct As CREATESTRUCT)
	ResetDBM()

	SetIniPath()
	ListUpComPort(GetDlgItem(hMainWnd,ComList))
	SendMessage(MWnd(MAPPING),CB_ADDSTRING,0,"LoROM" As Long)
	SendMessage(MWnd(MAPPING),CB_ADDSTRING,0,"HiROM" As Long)
	SendMessage(MWnd(MAPPING),CB_ADDSTRING,0,"S-DD1 HiROM" As Long)
	SendMessage(MWnd(MAPPING),CB_ADDSTRING,0,"SA-1 HiROM" As Long)
	SendMessage(MWnd(MAPPING),CB_ADDSTRING,0,"ExHiROM" As Long)
	SendMessage(MWnd(MAPPING),CB_ADDSTRING,0,"SPC7110 HiROM" As Long)
	SendMessage(MWnd(MAPPING),CB_ADDSTRING,0,"Special LoROM" As Long)
	SendMessage(MWnd(MAPPING),CB_ADDSTRING,0,"SF MEMORY MX15001" As Long)
	SendMessage(MWnd(MAPPING),CB_ADDSTRING,0,"LoROM + ST018" As Long)
	
    SendMessage(MWnd(EditBox1),WM_SETFONT,CreateFont(-12,0,0,0,400,0,0,0,SHIFTJIS_CHARSET,OUT_RASTER_PRECIS,0,DEFAULT_QUALITY,FIXED_PITCH,"ＭＳ ゴシック") As DWord ,TRUE)
	SendMessage(hMainWnd,WM_SETICON,ICON_SMALL,LoadImage(GetModuleHandle(0),IDI_ICON1 As BytePtr,IMAGE_ICON,GetSystemMetrics(SM_CXSMICON),GetSystemMetrics(SM_CYSMICON),LR_DEFAULTCOLOR) As Long)

	SetCheckBox(MWnd(CheckBox6),TRUE)

	SetDlgEnable(STATUS_CLOSED)

	Dim i AS Long, buf[100] AS Byte
	Dim tmp AS DWord
	For i=0 To 7
		tmp=&H80 << i
		SendMessage(MWnd(ROM_SIZE),CB_ADDSTRING,0,sprintfStr("%dKB [%dMbit]",(tmp) As DWord, (tmp*8)/(1024) As DWord) )
		tmp=&H02 << i
		SendMessage(MWnd(SRAM_SIZE),CB_ADDSTRING,0,sprintfStr("%dKB [%dKbit]",(tmp) As DWord, (tmp*8) As DWord) )
	Next i

	Dim baudrate As DWord
	baudrate=GetPrivateProfileInt(ProgramName,"BaudRate",DEFAULT_BAUDRATE,INIFILE_PATH)
	if baudrate=0 Then baudrate=DEFAULT_BAUDRATE

#IFDEF _DEBUG
MoveWindow(hMainWnd,0,0,475,330,TRUE)
#ENDIF

	SetWindowText(MWnd(EditBox6),Str$(baudrate))
End Sub

Sub SetIniPath()
	'INIファイルへのパスを記録
	Dim Path[MAX_PATH+20] As Byte,i As Long

	'自己のファイルパスを取得
		GetModuleFileName(NULL,Path,MAX_PATH)
		For i = lstrlen(Path) To 0 Step -1
			If Path[i]=&H5C then ExitFor' \ だったら
		Next i
		Path[i+1]=0'￥以下を潰す

	INIFILE_PATH=calloc(lstrlen(Path)+Len(INIFILE_NAME)+10)
	lstrcpy(INIFILE_PATH,Path)
	lstrcat(INIFILE_PATH,INIFILE_NAME)
EndSub

Sub ListUpComPort(Wnd As HWND)
	Dim buf As BytePtr,p As DWord,C As Long
	dim QDD_BUFSIZE As DWord

	QDD_BUFSIZE=GetPrivateProfileInt(ProgramName,"QDDSize",DEFAULT_QDD_BUFSIZE,INIFILE_PATH)
	if QDD_BUFSIZE<1024 Then 
		QDD_BUFSIZE=DEFAULT_QDD_BUFSIZE
		DBM("QDD size fixed.")
		WritePrivateProfileString(ProgramName,"QDDSize",Str$(QDD_BUFSIZE),INIFILE_PATH)
	endif

	SendMessage(Wnd,CB_RESETCONTENT,0,0)

	buf=calloc(QDD_BUFSIZE)
	if QueryDosDevice(NULL,buf,QDD_BUFSIZE) = 0 Then 
		SendMessage(Wnd,CB_ADDSTRING,0,"Error!" As Long)
		p=GetLastError()
		DBM(ex"COM Port Listup Error!\r\nCode."+Str$(p))
		if p=122 Then
			ErrMes(hMainWnd,ex"デバイスリストバッファのサイズが小さすぎます\n"+INIFILE_NAME+"を開き、QDDSizeの右辺の値を増やしてください。","QueryDosDevice Error",0)
		Endif
		Goto *LUCP_EXIT
	endif	
	Do
		if win_strncmp(buf+p,"COM",3)=TRUE Then
			SendMessage(Wnd,CB_ADDSTRING,0,(buf+p) As Long)

		/*	if lstrcmpi(buf+p,lastDevice)=0 Then _
				lastDeviceIdx=C
			
			DBM(sprintfStr(ex"%s ::: %s  idx=%d\n",buf+p,lastDevice,lastDeviceIdx))*/
			C++
		Endif
		While buf[p]<>0
			p++
		Wend
		p++
		if buf[p+1]=0 Then Exitdo	'ダブルNULLで終了
	Loop

*LUCP_EXIT
	free(buf)

	if C=0 then SendMessage(Wnd,CB_ADDSTRING,0,"None" As Long)

	'最後に選択されたポートを選ぶ
	Dim lastDevice aS BytePtr, lastDeviceIdx AS Long
	lastDevice=calloc(128)
	GetPrivateProfileString(ProgramName,"LastDevice","None",lastDevice,128,INIFILE_PATH)

	'探す
	lastDeviceIdx=SendMessage(Wnd,CB_FINDSTRINGEXACT,-1,lastDevice)
	if lastDeviceIdx=CB_ERR Then lastDeviceIdx=0

	'セットする
	SendMessage(Wnd,CB_SETCURSEL,lastDeviceIdx,0)
	 
	free(lastDevice)	
EndSub

Sub DBM(Text As BytePtr)
	Dim LastPos As DWord,hEB As  HANDLE
	hEB=MWnd(EditBox1)
	LastPos=GetWindowTextLength(hEB)

	'10KBを超えてたらログをクリア
	if LastPos>1024*10 Then
		'1KB残す
		Dim txt AS BytePtr
		txt=calloc(LastPos+1)
		GetWindowText(hEB,txt,LastPos)
		SetWindowText(hEB,txt+LastPos-1024)	
		free(txt)
		LastPos=1025
	End If

	SendMessage(hEB,EM_SETSEL,LastPos,LastPos)
	SendMessage(hEB,EM_REPLACESEL,0,Text As Long)
	SendMessage(hEB,EM_REPLACESEL,0,ex"\r\n" As Long)
	OutputDebugString(Text)
	OutputDebugString(ex"\r\n")
EndSub

Sub DBMN(Text As BytePtr)
	Dim LastPos As DWord,hEB As  HANDLE
	hEB=MWnd(EditBox1)
	LastPos=GetWindowTextLength(hEB)
	SendMessage(hEB,EM_SETSEL,LastPos,LastPos)
	SendMessage(hEB,EM_REPLACESEL,0,Text As Long)
EndSub


Sub MainWnd_CommandButton5_Click()
	'設定保存
	SaveIniFile()

	if hCOM=0 then
		'接続
		Dim txCom As BytePtr,rate As DWord

		rate=GetDlgItemInt(hMainWnd,EditBox6,NULL,FALSE)
		if rate=0 Then ErrMes(hMainWnd,"ボーレートが不正です。","Invalid baud rate",0):ExitSub

		txCom=GetWndTextMalloc(GetDlgItem(hMainWnd,ComList))
		DBM("Connect to "+MakeStr(txCom))

		'bufferlen
		Dim bufferSize AS DWord
		bufferSize=GetPrivateProfileInt(ProgramName,"DumpBufferSize",DEFAULT_DUMP_SIZE,INIFILE_PATH)
		if bufferSize <= 0 Then bufferSize=DEFAULT_DUMP_SIZE

		'connect and reset ボーレート
		hCOM=OpenComPort(txCom,INITIAL_BAUDRATE,bufferSize,1024*10)
		ResetArduino(hCOM)
		CloseHandle(hCOM)		
		
		'reconnect, 接続を確立
		hCOM=OpenComPort(txCom,INITIAL_BAUDRATE,bufferSize,1024*10)

		
		if hCOM = NULL Then 
			ErrMes(hMainWnd,MakeStr(txCom)+ex"への接続に失敗しました。","Connection failed",0,GetLastError())
			DBM("Serial connection Failed.")
			hCOM=0
			free(txCom)	
			ExitSub
		Else
			DBM(ex"Connection Stage1 OK.\r\n")
		endif
		free(txCom)	

		SetWindowText(MWnd(CommandButton5),"&Close")
		SetDlgEnable(STATUS_CONNECTED)

		'正常なデータ通信を確立(できるようになるまでリトライ）
		if CheckFirmware(hCOM,TRUE)=FALSE Then 
		'	ErrMes(hMainWnd,"指定されたデバイスはHongKoongArduinoではありません。",0,0)
			goto *HKAF_CON_ERR
		Endif
		DBM(ex"Connection Stage2 OK.\r\n")

		'ボーレート変更コマンド送信
		ChangeBaudrate(hCOM,rate)
		DBM("baudrate="+Str$(rate)+"bps")
		
		'変更後の正常なデータ通信を確立
		DBM("changeing baudrate...")
		if CheckFirmware(hCOM,FALSE)=FALSE Then 
			DBM("invailde baudrate")
			goto *HKAF_CON_ERR
		End If

		DBM(ex"Connection Successful!!!\r\n")

		'GetCartInfo
		MainWnd_CommandButton1_Click()

	Else
		'切断
		DisconnectDevice()
		
	endif

	ExitSub
*HKAF_CON_ERR
	DisconnectDevice()
	SetWindowText(MWnd(SRAM_SIZE),"")
	SetWindowText(MWnd(ROM_SIZE),"")
	SetWindowText(MWnd(ROMTITLE),"")
	SetWindowText(MWnd(CART_CIPS),"")
	SetWindowText(MWnd(MAPPING),"")
End Sub

Sub DisconnectDevice()
	if hCOM=0 Then ExitSub
	CloseHandle(hCOM)
	hCOM=0
	SetWindowText(MWnd(CommandButton5),"&Connect")
	SetDlgEnable(STATUS_CLOSED)

	DBM(ex"Connection is closed.\r\n")
End Sub

Sub SetDlgEnable(Mode As DLG_STATUS)
	'ボタンの有効/無効セット

	Dim isEnable As Long
	if Mode=STATUS_CONNECTED Or Mode=STATUS_DUMPING then
		isEnable=FALSE
	Else Mode=STATUS_CLOSED Then
		isEnable=TRUE
	endif
	EnableWindow(MWnd(ComList),isEnable)
	EnableWindow(MWnd(EditBox6),isEnable)
	EnableWindow(MWnd(Static9),isEnable)
	EnableWindow(MWnd(Static10),isEnable)

	if Mode=STATUS_DUMPING Then isEnable=NOT(isEnable) And &H01

	EnableWindow(MWnd(CommandButton1),NOT(isEnable) And &H01)
	EnableWindow(MWnd(CommandButton2),NOT(isEnable) And &H01)
	EnableWindow(MWnd(CommandButton3),NOT(isEnable) And &H01)
	EnableWindow(MWnd(CommandButton4),NOT(isEnable) And &H01)
	EnableWindow(MWnd(CommandButton17),NOT(isEnable) And &H01)	

	EnableWindow(MWnd(MAPPING),NOT(isEnable) And &H01)	
	EnableWindow(MWnd(ROM_SIZE),NOT(isEnable) And &H01)	
	EnableWindow(MWnd(SRAM_SIZE),NOT(isEnable) And &H01)	
	EnableWindow(MWnd(CB_MANUAL),NOT(isEnable) And &H01)	
	
	if Mode=STATUS_DUMPING Then 
		EnableWindow(MWnd(CommandButton5),FALSE)
	Else
		EnableWindow(MWnd(CommandButton5),TRUE)		
	endif

	DlgStatus=Mode
EndSub

Function GetWndTextMalloc(hWnd As HWND) As BytePtr
	'コントロールのテキスト取得
	Dim buf As BytePtr
	buf=calloc(GetWindowTextLength(hWnd)+20)
	GetWindowText(hWnd,buf,GetWindowTextLength(hWnd)+1)

	GetWndTextMalloc=buf
EndFunction
Declare Function GetNextDlgTabItem Lib "user32" Alias "GetNextDlgTabItem" (ByVal hDlg As Long, ByVal hCtl As Long, ByVal bPrevious As Long) As Long 

Sub MainWnd_KeyUp(KeyCode As Long, flags As Long)
'	DBM("PressKey:"+Hex$(KeyCode))
	Select Case KeyCode
		Case &H70 : SpeedTest()	'F1
		Case &H71 : CheckFirmware(hCOM,FALSE)	'F2
		Case &H74 : ListUpComPort(GetDlgItem(hMainWnd,ComList))
		Case &H78 : MainWnd_CommandButton12_Click()
		Case &H7A : MainWnd_CommandButton15_Click()
		Case &H7B : MainWnd_CommandButton13_Click()

		'(このメッセージはフォーカスが無い状態なので)TABキーが押されたら適当なボタンにフォーカスを当てる
		'Case VK_TAB : SetFocus( GetNextDlgTabItem(hMainWnd, 0, TRUE))
	EndSelect
End Sub

Sub SpeedTest()
	'Arduinoとの接続速度テスト
	Dim rd As BytePtr,mes[256] As Byte,total As DWord,lt As DWord,i As Long
	Const TEST_READ_SIZE=1024*10
	DBM("Speedtest : Read "+Str$(TEST_READ_SIZE/1024)+"KB*10")
	rd=calloc(TEST_READ_SIZE)
	total=0:lt=0
	For i = 0 To 9
		lt=GetTickCount()
		ReadROM(hCOM,rd, 0, i*TEST_READ_SIZE, TEST_READ_SIZE,FALSE)
		total+=GetTickCount()-lt
		wsprintf(mes,ex"\t[%d]Time : %dms",i,GetTickCount()-lt)
		DBM(mes)
	Next i
	wsprintf(mes,ex"Total:%dms\r\nAverage:%dms\r\nSpeed : %dbyte/sec (%dKB/s)\r\n",total,total/9,(TEST_READ_SIZE*10)/(total/1000),(TEST_READ_SIZE*10)/(total/1000)/1000)
	DBM(mes)
	free(rd)
End Sub



Sub MainWnd_CommandButton2_Click()
	'ROM吸出しボタン

	Dim info As SFC_CART_INFO
	Dim path As BytePtr

	GetDumpConfig(info)
'	info.ROMSize = &H400000	'debug

#ifndef _DEBUG
	path=SaveDialogCalloc(ex"SFC ROMイメージファイル(*.sfc)\0*.sfc\0すべてのファイル(*.*)\0*.*\0\0","sfc",info.Title)
	if path=0 Then ExitSub
#else
	path="dump.sfc"
#endif

	DumpFullROM(VarPtr(info),path)

#ifndef _DEBUG
	free(path)
#endif

	MessageBeep(MB_ICONASTERISK)
End Sub

Sub MainWnd_QueryClose(ByRef cancel As Integer)
	SaveIniFile()
End Sub

Sub SaveIniFile()
	Dim ratestr As BytePtr,Tmp As DWord

	ratestr=GetWndTextMalloc(MWnd(EditBox6))
	WritePrivateProfileString(ProgramName,"BaudRate",ratestr,INIFILE_PATH)
	free(ratestr)
	
	ratestr=GetWndTextMalloc(MWnd(ComList))
	WritePrivateProfileString(ProgramName,"LastDevice",ratestr,INIFILE_PATH)
	free(ratestr)

	Tmp=GetPrivateProfileInt(ProgramName,"MaxContinue",DEFAULT_CONTINUE,INIFILE_PATH)
	WritePrivateProfileString(ProgramName,"MaxContinue",Str$(Tmp),INIFILE_PATH)

	Tmp=GetPrivateProfileInt(ProgramName,"QDDSize",DEFAULT_QDD_BUFSIZE,INIFILE_PATH)
	if Tmp=0 Then Tmp=DEFAULT_QDD_BUFSIZE
	WritePrivateProfileString(ProgramName,"QDDSize",Str$(Tmp),INIFILE_PATH)
	
	Tmp=GetPrivateProfileInt(ProgramName,"DumpBufferSize",DEFAULT_DUMP_SIZE,INIFILE_PATH)
	if Tmp <= 0 Then Tmp=DEFAULT_DUMP_SIZE
	WritePrivateProfileString(ProgramName,"DumpBufferSize",Str$(Tmp),INIFILE_PATH)
	
	WritePrivateProfileString(ProgramName,"RxTimeoutMargine",Str$(HKAC_RX_TIMEOUT_MARGIN),INIFILE_PATH)
EndSub

Sub MainWnd_CommandButton3_Click()
	Dim info As SFC_CART_INFO
	Dim path As BytePtr

	GetDumpConfig(info)
#ifndef _DEBUG
	path=SaveDialogCalloc(ex"SRAMイメージファイル(*.srm)\0*.srm\0すべてのファイル(*.*)\0*.*\0\0","srm",info.Title)
	if path=0 Then ExitSub
#else
	path="dump.srm"
#endif

	DumpSRAM(hCOM,VarPtr(info),path)
#ifndef _DEBUG
	free(path)
#endif
	MessageBeep(MB_ICONASTERISK)

End Sub

Sub MainWnd_CommandButton4_Click()
	Dim path As BytePtr

	Dim info As SFC_CART_INFO
	GetDumpConfig(info)
	
	if info.isFlashSave Then
		ErrMes(hMainWnd,"フラッシュメモリ方式のセーブデータ書き込みは現在未実装です。","未実装",0)
		if GetKeyState(VK_ESCAPE) And &H80 = 0 Then		exitsub
	End If

#ifndef _DEBUG
	path=LoadDialogCalloc(ex"SRAMイメージファイル(*.srm)\0*.srm\0すべてのファイル(*.*)\0*.*\0\0","srm")
	if path=0 Then ExitSub
#else
	if GetKeyState(VK_ESCAPE) And &H80 Then
		path=LoadDialogCalloc(ex"SRAMイメージファイル(*.srm)\0*.srm\0すべてのファイル(*.*)\0*.*\0\0","srm")
	Else
		path="write.srm"
	End If

#endif
	if MessageBox(hMainWnd,ex"セーブデータが上書きされます。\nまた、正常に書き込める保障はありません。\n続行しますか？",ProgramName+" - SRAM write",MB_YESNO or MB_ICONWARNING) = IDNO Then ExitSub
	WriteSRAM(hCOM,VarPtr(info),path)
#ifndef _DEBUG
	free(path)
#endif
	MessageBeep(MB_ICONASTERISK)
End Sub


Function SaveDialogCalloc(filter As BytePtr,ext As String)(defFileName As BytePtr)	As BytePtr
	Dim tOfn As OPENFILENAME,i As DWord

	'ファイルオープン構造体の初期化
	tOfn.lStructSize = SizeOf(OPENFILENAME)-SizeOf(DWord)*2-SizeOf(VoidPtr)
	tOfn.hwndOwner = hMainWnd
	tOfn.lpstrFilter = filter'ex"wavファイル(*.wav)\0*.wav\0すべてのファイル(*.*)\0*.*\0\0"'StrPtr(sFilter)
	tOfn.nFilterIndex = 1
	tOfn.nMaxFile = MAX_PATH
	tOfn.Flags=OFN_OVERWRITEPROMPT
	tOfn.lpstrDefExt=StrPtr(ext)'"wav"
	tOfn.lpstrFile = calloc(MAX_PATH+10)
	if defFileName<>0 Then lstrcpy(tOfn.lpstrFile,defFileName)

	'ファイルオープンダイアログを表示する
	If GetSaveFileName(tOfn) = 0 Then
		ExitFunction
	End If
	
	SaveDialogCalloc=calloc(lstrlen(tOfn.lpstrFile)+1)
	lstrcpy(SaveDialogCalloc,tOfn.lpstrFile)
	free(tOfn.lpstrFile)
EndFunction

Function LoadDialogCalloc(filter As BytePtr,ext As String)	As BytePtr
	Dim tOfn As OPENFILENAME,i As DWord

	'ファイルオープン構造体の初期化
	tOfn.lStructSize = SizeOf(OPENFILENAME)-SizeOf(DWord)*2-SizeOf(VoidPtr)
	tOfn.hwndOwner = hMainWnd
	tOfn.lpstrFilter = filter'ex"wavファイル(*.wav)\0*.wav\0すべてのファイル(*.*)\0*.*\0\0"'StrPtr(sFilter)
	tOfn.nFilterIndex = 1
	tOfn.nMaxFile = MAX_PATH
	tOfn.Flags=OFN_OVERWRITEPROMPT
	tOfn.lpstrDefExt=StrPtr(ext)'"wav"
	tOfn.lpstrFile = calloc(MAX_PATH+10)

	'ファイルオープンダイアログを表示する
	If GetOpenFileName(tOfn) = 0 Then
		ExitFunction
	End If
	
	LoadDialogCalloc=calloc(lstrlen(tOfn.lpstrFile)+1)
	lstrcpy(LoadDialogCalloc,tOfn.lpstrFile)
	free(tOfn.lpstrFile)
EndFunction

Sub MainWnd_RButtonDblClick(flags As Long, x As Integer, y As Integer)
	ResetDBM()
	DBM("Cleared Log.")
End Sub

Sub MainWnd_Static1_DblClick()
	exec("http://hongkongarduino.web.fc2.com/")
End Sub

'リードテスト
Sub MainWnd_CommandButton6_Click()
	if hCOM=0 Then ExitSub
	Dim data As BytePtr,adr As DWord
	data=calloc(&H10000)
	adr=GetDlgItemHex(MWnd(EditBox2))
	DBM("Dump 0x"+Hex$(adr))

	ReadROM(hCOM,data,0,adr,&h5000,NOT(GetCheckBox(MWnd(CheckBox6))) And &H01)
	Dim f As File
	f.openFile("test.bin",GENERIC_WRITE)
	f.write(data,&h5000)
	f.close()
	DBM("OK")
	Dim p As BytePtr,i As Long
	p=data+&H5000
	For i=0 To 7
		p+=wsprintf(p,"%02X ",data[i])
	Next i
	p+=wsprintf(p,ex"\r\n",data[i])
	For i=0 To 7
		p+=wsprintf(p,"[%c]",data[i])
	Next i
	DBM(data+&H5000)
	Dump(data,128)
End Sub

Sub MainWnd_MButtonDblClick(flags As Long, x As Integer, y As Integer)
	'ESC+マウス中ボタンダブルクリックでテストモード
	if GetCancelKey() Then 
		MoveWindow(hMainWnd,0,0,475,330,TRUE)
		AllocConsole()
		_System_hConsoleOut=GetStdHandle(STD_OUTPUT_HANDLE)
		printf("Welcome to debug mode")
	Endif

End Sub



Sub MainWnd_CommandButton8_Click()
	if hCOM=0 Then ExitSub
	Dim ctrl As Byte
	ctrl=(GetCheckBox(MWnd(CheckBox2))<<3 or GetCheckBox(MWnd(CheckBox3))<<2 or _
		GetCheckBox(MWnd(CheckBox4))<<1 or GetCheckBox(MWnd(CheckBox5))) As Byte
	DBM("SetCtrlBus : 0"+Hex$(ctrl))

	SendControl(hCOM,ctrl)
End Sub

Sub MainWnd_CommandButton9_Click()
	DBM("回路デバッグモード")
	DBM("ESCキーで抜ける")
	Do
		MainWnd_CommandButton1_Click()
		Sleep(300)
		PumpMessage()
		if GetKeyState(VK_ESCAPE) And &H80 Then ExitDo
	Loop
End Sub

Sub MainWnd_CommandButton1_Click()
	SetRomInfoToDlg_FromROM()
End Sub

Sub SetRomInfoToDlg_FromROM()
	Dim buf[SFC_SPEC_HEADER_SIZE+2] As Byte,cartInfo As SFC_CART_INFO
	DBM( "Cartridge Infomation")

	'ヘッダを読み出し＆ダイアログに情報を表示
	FlushCom(hCOM)
	getCartInfo(cartInfo)

	'ダイアログに表示
	SetCartInfo(VarPtr(cartInfo),TRUE)

	'Manualのチェックを外す
	SetCheckBox(MWnd(CB_MANUAL),FALSE)

	'BSスロットがあればBSMWndを出す
	if cartInfo.isBSX Then
		BSM_open()

		Dim idx AS Long
		if cartInfo.CartType=&HE5 Then
			idx=BSM_SLOT_BIOS
		Elseif cartInfo.ROMType=SFC_MAP_LoROM or cartInfo.ROMType=SFC_MAP_SpLoROM then
			idx=BSM_SLOT_SpLoROM
		Elseif cartInfo.ROMType=SFC_MAP_HiROM then
			idx=BSM_SLOT_HiROM
		Elseif cartInfo.ROMType=SFC_MAP_SA1 then
			idx=BSM_SLOT_SA1
		Else
			DBM("[!!!]Warning: unknown BS-X slot")
		End If
	'	debug
		SendMessage(BSMWnd(BSM_CT),CB_SETCURSEL,idx,0)
		PumpMessage()
	Else
		BSM_close()
	End If
	
	if cartInfo.ROMType=SFC_MAP_SF_MENU Then
		SFM_open()
	End if	

	SetCheckBox(MWnd(CheckBox7),hasClockModule(hCOM))

	'アクセスランプをLow
	SetAddress(hCOM,&H000000,FALSE)
End Sub



Sub MainWnd_CommandButton10_Click()
	SPC7110_PrintBanks(hCOM)
	SPC7110_SetBanks(hCOM,0,TRUE)
	SPC7110_PrintBanks(hCOM)
	SPC7110_SetBanks(hCOM,0,FALSE)
	SPC7110_PrintBanks(hCOM)
End Sub


'---------------------------------------------------------------------------------------------------


'吸出し設定をROMとGUIから読み出し
Sub GetDumpConfig(ByRef info As SFC_CART_INFO)
	getCartInfo(info)

	GetDlgOption(info)	'infoにGUIの設定を反映

	SetCartInfo(VarPtr(info),FALSE)
EndSub


Sub getCartInfo(ByRef info As SFC_CART_INFO)
	'カートリッジからヘッダをロード
	Dim buf[SFC_SPEC_HEADER_SIZE+5] As Byte
	/*ReadROM(hCOM,buf, 0, SFC_SPEC_HEADER_ADDR, SFC_SPEC_HEADER_SIZE,FALSE)
	SloveCartInfo(buf As *SFC_CART_HEADER,VarPtr(info))*/
	
'	SetCPU_Clock(hCOM,HKAC_CLOCK_NORMAL)	'clock
	SendControl(hCOM,DEFAULT_CTRLBUS)	'default

	if ReadROM(hCOM,buf, 0, SFC_SPEC_HEADER_ADDR, SFC_SPEC_HEADER_SIZE,FALSE)<SFC_SPEC_HEADER_SIZE Then
		lstrcpy(info.Title,"[ERR]通信エラー")
		SetCartInfo(VarPtr(info),TRUE)
		ErrMes(hMainWnd,ex"通信エラーが発生しました。\nArduinoをリセットしてください。","Device was lost",0)
		DisconnectDevice()
		ExitSub
	End If
	SloveCartInfo(buf As *SFC_CART_HEADER,VarPtr(info))
End Sub

Function getSelectedMapMode() AS Byte
	Dim mapperTable[SFC_MAP_TYPE_NUM]=[ _
		SFC_MAP_LoROM, _
		SFC_MAP_HiROM, _
		SFC_MAP_SDD1, _
		SFC_MAP_SA1, _
		SFC_MAP_ExHiROM, _
		SFC_MAP_SPC7110, _
		SFC_MAP_SpLoROM, _
		SFC_MAP_SF_MENU, _
		SFC_MAP_ST018 _
	] As Byte, idx As Long

	idx=SendMessage(MWnd(MAPPING),CB_GETCURSEL,0,0) Mod SFC_MAP_TYPE_NUM
	getSelectedMapMode=mapperTable[idx]

End Function

Sub GetDlgOption(ByRef info As SFC_CART_INFO) 
	'LoROM/HiROMの選択とMAD1のチェック取得
	if GetCheckBox(MWnd(CB_MANUAL)) Then
		info.ROMType=getSelectedMapMode() As Byte
		info.MapMode = (info.MapMode And &HF0) or info.ROMType
		info.ROMSize = HKAC_GetWindowInt(MWnd(ROM_SIZE))
		info.SRAMSize = HKAC_GetWindowInt(MWnd(SRAM_SIZE))
		printf(ex"custom rom size = %d\n",info.ROMSize/1024/1024)

		if info.ROMType=SFC_MAP_LoROM or info.ROMType=SFC_MAP_SpLoROM or info.ROMType=SFC_MAP_SF_MENU Then
			info.AddrOffset=0
			info.isLoROM=TRUE
		Else
			info.AddrOffset=HiROM_START_ADR
			info.isLoROM=FALSE
		End If

	End If

EndSub


'MapMode (20 SrowRom LoROMのやつ）のGUI用関数
Function MapModeToComboboxIndex(mapMode As Byte) As Long
	Dim mapTable[SFC_MAP_TYPE_NUM]=[ &H00, &H01, &H02, &H03, &H05, &H0A, &HF0, &HF1, &HF2] As Byte
	Dim romMap As Byte
	Dim i As Long

	romMap=mapMode

	For i=0 To SFC_MAP_TYPE_NUM
		if mapTable[i]=romMap Then 
			MapModeToComboboxIndex=i
			ExitFor
		End If
	Next
End Function

Function GetRomSpeedString(mapMode As Byte) As BytePtr
	if (mapMode And &H20) Then
		GetRomSpeedString="Fast"
	Else
		GetRomSpeedString="Slow"
	End If
End Function

Function GetRomMapString(mapMode As Byte) As BytePtr
	Select Case (mapMode And &H0F)
		Case 0
			GetRomMapString="LoROM"
		Case 1
			GetRomMapString="HiROM"
		Case 2
			GetRomMapString="S-DD1"
		Case 3
			GetRomMapString="SA-1"
		Case 5
			GetRomMapString="ExHiROM"
		Case &H0A
			GetRomMapString="SPC7110"
		Case Else
			GetRomMapString="unknown"
	End Select	
End Function


'カートリッジ情報をGUIに反映
Sub SetCartInfo(info As *SFC_CART_INFO,bMessageOutput AS BOOL)
	'このルーチンからはManualのチェックが変わらないようにする
	Dim bManual AS BOOL
	bManual=GetCheckBox(MWnd(CB_MANUAL))

	Dim CartChip[512] As Byte
	Const UNK_CART_TYPE_TEXT = "+???"

	SetWindowText(MWnd(ROMTITLE),info->Title)
	SendMessage(MWnd(MAPPING),CB_SETCURSEL,MapModeToComboboxIndex(info->ROMType),0)
	MainWnd_MAPPING_SelChange()

	lstrcpy(CartChip,"ROM")

	'http://snesemu.black-ship.net/misc/hardware/-from%20nsrt.edgeemu.com-chipinfo.htm
	Select Case info->CartType>>4
		Case &H00
			Select Case info->CartType And &H0F
				Case &H00 : lstrcat(CartChip,"")
				Case &H01 : lstrcat(CartChip,"+RAM")
				Case &H02 : lstrcat(CartChip,"+RAM+BAT")
				Case &H03 : lstrcat(CartChip,"+DSP")
				Case &H04 : lstrcat(CartChip,"+DSP+RAM")
				Case &H05 : lstrcat(CartChip,"+DSP+RAM+BAT")
				Case Else : lstrcat(CartChip,UNK_CART_TYPE_TEXT)
			EndSelect
		Case &H01 'SuperFX
			Select Case info->CartType And &H0F
				Case &H03 : lstrcat(CartChip,"+MARIO+RAM")
				Case &H04 : lstrcat(CartChip,"+GSU+RAM")
				Case &H05 : lstrcat(CartChip,"+GSU+RAM+BAT")
				Case &H0A : lstrcat(CartChip,"+GSU1+RAM+BAT")
				Case Else : lstrcat(CartChip,UNK_CART_TYPE_TEXT)
			EndSelect
			lstrcat(CartChip," [SuperFX]")
		Case &H02 : lstrcat(CartChip,"+OBC1+RAM+BAT")
		Case &H03 
			lstrcat(CartChip,"+SA-1+RAM")
			if info->CartType = &H34 Then
			Elseif info->CartType = &H35 then
				 lstrcat(CartChip,"+BAT")
			Else
				lstrcat(CartChip,UNK_CART_TYPE_TEXT)
			endif
		Case &H04
			lstrcat(CartChip,"+SDD1+")
			if (info->CartType And &H0F) = 3 Then
			Elseif info->CartType = &H45 then
				 lstrcat(CartChip,"RAM+BAT")
			Else
				lstrcat(CartChip,UNK_CART_TYPE_TEXT)
			endif
		Case &H05 : lstrcat(CartChip,"S-RTC+RAM+BAT")
		Case &H0E 
			Select Case info->CartType And &H0F
				Case &H03 : lstrcat(CartChip,"+SGB+RAM")
				Case &H05 : lstrcat(CartChip,"+BS-X")
				Case &H0A : lstrcat(CartChip,"+CX4")
				Case Else : lstrcat(CartChip,UNK_CART_TYPE_TEXT)
			EndSelect
		Case &H0F
			Select Case (info->CartType And &H0F) As DWord
				Case &H03 : lstrcat(CartChip,"+CX4")
				Case &H05
					if info->isLoROM Then
						lstrcat(CartChip,"+ST018+RAM+BAT")
					Else
						lstrcat(CartChip,"+SPC7110+RAM+BAT")
					endif
				Case &H0A6
					if info->ROMSize=&H100000 Then
						lstrcat(CartChip,"+ST010")
					Else
						lstrcat(CartChip,"+ST011")
					endif
				Case &H09 : lstrcat(CartChip,"+SPC7110+RAM+BAT+RTC")
				Case Else : lstrcat(CartChip,UNK_CART_TYPE_TEXT)
			EndSelect
		Case Else
			lstrcat(CartChip," UNKNOWN CART TYPE")
	EndSelect

	SetWindowText(MWnd(CART_CIPS),CartChip)
	
	if info->ROMSize =0 Then
		SetWindowText(MWnd(ROM_SIZE),"None")		
	Else
		SetWindowText(MWnd(ROM_SIZE),sprintfStr("%dKB [%dMbit]",
							(info->ROMSize/1024) As DWord, (info->ROMSize*8)/(1024^2) As DWord))
	endif
	if info->SRAMSize =0 Then
		SetWindowText(MWnd(SRAM_SIZE),"None")		
	Else
		Dim FLASH_TEXT AS BytePtr
		if info->isFlashSave Then
			FLASH_TEXT="[FLASH]"
		Else
			FLASH_TEXT=""
		End If
		SetWindowText(MWnd(SRAM_SIZE),sprintfStr("%dKB [%dKbit]%s",
							(info->SRAMSize/1024) As DWord, (info->SRAMSize*8)/(1024) As DWord,FLASH_TEXT))
	endif

	SetCheckBox(MWnd(CB_MANUAL),bManual)
	
	if bMessageOutput Then	
		DBMN("Chips: ")
		wsprintf(CartChip+lstrlen(CartChip),ex" [0x%02X]",info->CartType)
		DBM(CartChip)
		
		DBM(sprintfStr("MapMode :[%02X]%s%s",info->MapMode,GetRomSpeedString(info->MapMode),GetRomMapString(info->MapMode)))

		DBMN("Country : ")
		Select Case info->Country
			Case 00 : DBM("Japan")
			Case 01 : DBM("USA")
			Case 02 : DBM("Europe")
			Case 03 : DBM("(unknown)")
		EndSelect

		DBM(ex"Version : "+Str$(info->Version/10+1.0))
		if info->hasExtraHeader Then
			'DBM("Extra Header Found.")
			DBM(sprintfStr("MakerID : [%c%c] %s", info->MakerCode , info->MakerCode >> 8, info->MakerName))
			DBMN("GameCode: SHVC-"): DBM(info->GameCode)
		End If

		DBM("CheckSum1(sum) : "+Hex$(info->CheckSum1))
		DBM("CheckSum2(rev) : "+Hex$(info->CheckSum2))

		DBM("")
		if info->isBSX Then	DBM(ex"BS Memory Slot detected.\r\n")
		if info->isFlashSave Then DBM(ex"Save Flash detected.\r\n")
	End If
EndSub	

Function GetCheckBox(Ctrl As HWND) As Byte
	if SendMessage(Ctrl,BM_GETCHECK,0,0) = BST_CHECKED then
		GetCheckBox=TRUE
	Else
		GetCheckBox=FALSE
	endif
endfunction
Function SetCheckBox(Ctrl As HWND,bValue As BOOL) As Byte
	SendMessage(Ctrl,BM_SETCHECK,bValue,bValue)
endfunction


Sub MainWnd_CheckBox6_Click()

End Sub

Sub RomCommand(Adr As DWord,val As DWord)
	Dim loAdr As DWord,tmp As DWord
	loAdr=&H8000 or (Adr And &H7FFF) or (Adr And &HFF8000)<<1
	DBM("CMD:"+Hex$(loAdr)+":"+Hex$(val))
	WriteROM(hCOM,VarPtr(val),0,Adr,1,TRUE)
End Sub

Sub MainWnd_CommandButton11_Click()
/*	Dim buf[20+512] As Byte
	RomCommand(BSX_MEMPACK_ADR_LoROM,&H38)
	RomCommand(BSX_MEMPACK_ADR_LoROM,&HD0)
	RomCommand(BSX_MEMPACK_ADR_LoROM,&H71)
	ReadROM(hCOM,buf,0,BSX_MEMPACK_ADR_LoROM,1,TRUE)
	DBM(Hex$(buf[0]))
	Sleep(50)
	ReadROM(hCOM,buf,0,BSX_MEMPACK_ADR_LoROM,1,TRUE)
	DBM(Hex$(buf[0]))
	RomCommand(BSX_MEMPACK_ADR_LoROM,&H72)
	RomCommand(BSX_MEMPACK_ADR_LoROM,&H75)
	ReadROM(hCOM,buf,0,BSX_MEMPACK_ADR_LoROM+&HFF00,20,TRUE)
	Dim p As BytePtr,i As Long
	p=buf+30
	For i=0 To 20
		p+=wsprintf(p,"%02X ",buf[i])
	Next i
	p+=wsprintf(p,ex"\r\n",buf[i])
	For i=0 To 20
		p+=wsprintf(p,"[%c]",buf[i])
	Next i
	p+=wsprintf(p,ex"\r\n",buf[i])
	p+=wsprintf(p,ex"\r\n",buf[i])
	DBM(buf+30)

	DBM(buf)
*/
	BSM_open()

End Sub


Function Lo2Hi(Adr As DWord) As DWord
	Lo2Hi= (Adr And &HFF8000)<<1 or (Adr And &H007FFF) or &H8000 

End Function


Sub MainWnd_DropFiles(hDrop As HDROP)
	Dim buf[MAX_PATH] As Byte
	Dim i as long

	DBM("ROM File Infomation : ")
	Do
		If DragQueryFile(hDrop,i,buf,MAX_PATH)=0 Then Exit Do
		i++
	Loop
	DragFinish(hDrop)	
	
	Dim file AS File,header As SFC_CART_HEADER,cartInfo AS SFC_CART_INFO
	if file.openFile(buf,GENERIC_READ)=FALSE Then ExitSub

	'ヘッダ位置候補 HiROM,LoROM,HiROM(ヘッダ付き),LoROM(ヘッダ付き)
	Dim headerAdrs[4] = [&HFFB0,&H7FB0,&HFFB0+&H200,&H7FB0+&H200] AS DWord
	For i = 0 To 3
		file.setFilePtr(headerAdrs[i])
		file.read(VarPtr(header),SFC_SPEC_HEADER_SIZE)

		if isSnesHeader(VarPtr(header))=TRUE Then ExitFor
	Next i

	file.close()
	
	if isSnesHeader(VarPtr(header))=FALSE Then
		DBM(ex"ROM Header not found!\r\n")
		MessageBeep(MB_ICONEXCLAMATION)
		ExitSub
	Else
		DBM("Found header at 0x"+Hex$(headerAdrs[i]))
	End If
	
	SloveCartInfo(VarPtr(header),VarPtr(cartInfo))
	SetCartInfo(VarPtr(cartInfo),TRUE)

	
End Sub



'これやるとOSとデバイス間の通信も切れる
Sub ResetArduino(hCOM AS HANDLE)
	EscapeCommFunction(hCOM,SETDTR)
	Sleep(50)
	EscapeCommFunction(hCOM,CLRDTR)
	Sleep(50)
End Sub


Sub MainWnd_CommandButton12_Click()
	DBM("CPU CLOCK OVERCLOCKED")
	SetCPU_Clock(hCOM,HKAC_CLOCK_CPU_OVERCLOCKED)

End Sub

Sub MainWnd_CommandButton15_Click()

End Sub

Sub MainWnd_CommandButton13_Click()
	DBM("CPU CLOCK DISABLE")
	SetCPU_Clock(hCOM,HKAC_CLOCK_DISABLED)
End Sub

Sub MainWnd_CommandButton14_Click()
	SFM_open()
End Sub

Dim MW_bMove AS BOOL
Sub MainWnd_Move(x As Integer, y As Integer)
	if MW_bMove=TRUE Then ExitSub

	if hSFMem<>NULL then
		MoveChildWindow(hMainWnd,hSFMem)
	Endif
	if hBSMem<>NULL Then
		MoveChildWindow(hMainWnd,hBSMem)
	End If
End Sub

Sub MoveChildWindow(owner AS HWND,child AS HWND)
	Dim rect aS RECT
	GetWindowRect(owner,rect)
	rect.right=rect.right+GetSystemMetrics(SM_CXSIZEFRAME)*2'10
	'面白い挙動するので残しておく
	'SetWindowPos(hSFMem,NULL,rect.top,rect.right,0,0,SWP_NOSIZE or SWP_SHOWWINDOW)

	MW_bMove=TRUE
	SetWindowPos(child,NULL,rect.right,rect.top,0,0,SWP_NOSIZE or SWP_NOZORDER or SWP_NOOWNERZORDER or SWP_NOACTIVATE)
	MW_bMove=FALSE
End Sub


Sub MainWnd_MAPPING_SelChange()
	Dim SelectedMapMode AS Long
	SelectedMapMode=getSelectedMapMode()

	if SelectedMapMode=SFC_MAP_SF_MENU Then
		ShowWindow(MWnd(CommandButton14),SW_SHOW)
	Else
		ShowWindow(MWnd(CommandButton14),SW_HIDE)
	End If

	if SelectedMapMode=SFC_MAP_ST018 Then
		ShowWindow(MWnd(CommandButton17),SW_SHOW)
	Else
		ShowWindow(MWnd(CommandButton17),SW_HIDE)
	End If


	'いじったらマニュアルチェックを付ける
	SetCheckBox(MWnd(CB_MANUAL),TRUE)
End Sub

Sub MainWnd_CheckBox1_Click()

End Sub

Function GetCancelKey() AS BOOL
	if (GetKeyState(VK_ESCAPE) And &H80) And (fWindowActive=TRUE) Then
		GetCancelKey=TRUE
	Else
		GetCancelKey=FALSE
	End If
End Function

Sub MainWnd_Activate(state As Integer, minimized As Integer)
	if state=WA_INACTIVE Then
		fWindowActive=FALSE
	Else
		fWindowActive=TRUE
	End If
End Sub

Sub MainWnd_CommandButton16_Click()
		SetDlgEnable(STATUS_CONNECTED)
End Sub

Sub MainWnd_ROM_SIZE_SelChange():	SetCheckBox(MWnd(CB_MANUAL),TRUE):DBM("test3"):	End Sub
Sub MainWnd_SRAM_SIZE_SelChange():	SetCheckBox(MWnd(CB_MANUAL),TRUE):	End Sub
Sub MainWnd_ROM_SIZE_EditChange():	SetCheckBox(MWnd(CB_MANUAL),TRUE):	End Sub
Sub MainWnd_SRAM_SIZE_EditChange():	SetCheckBox(MWnd(CB_MANUAL),TRUE):	End Sub
Sub MainWnd_MAPPING_EditChange():	SetCheckBox(MWnd(CB_MANUAL),TRUE):	End Sub

Function HKAC_GetWindowInt(hWnd AS HWND) AS Long
	Dim str AS BytePtr
	str=GetWndTextMalloc(hWnd)
	rcAsciiToInt(str,VarPtr(HKAC_GetWindowInt),0,TRUE)
	free(str)
End Function

'(文字列, 変換結果を入れるところ, 基数, 1024か1000か)
Function rcAsciiToInt(_str AS BytePtr,result_num AS *Long)(_base AS DWord,b1024 AS BOOL) AS BOOL
	Dim ci AS DWord, ni AS DWord 'char index, num index
	Dim fNegative AS BOOL, fFixedBase AS BOOL
	Dim base AS DWord, siZoom AS DWord
	Dim num AS DWord
	Dim state AS DWord
	Dim str As BytePtr

	'基数
	'引数のbaseが0だとAuto, それ以外は固定, 最大１６まで
	if _base=<1 Then	
		base = 10
	Else 
		base=_base
		fFixedBase=TRUE
	End If

	'si接頭辞があるときに、1000で計算するか1024で計算するか
	if b1024 Then
		siZoom=1024
	Else
		siZoom=1000
	End If

	str=calloc(lstrlen(_str)+4)
	lstrcpy(str,_str)
	CharLower(str)

	Do 
		'文字列の終了チェック
		if str[ci]=0 Then ExitDo

		'数値に入る前の処理
		if state=0 Then
			if str[ci] = &H2D Then
				fNegative=TRUE
				ci++
				continue
			Else if str[ci] = &H30 then
				'16進 0x
				if str[ci+1]=&H78 Then
					base=16
					ci+=2
					continue

				'2進 0b
				Else if str[ci+1]=&H62 Then
					base=2 
					ci+=2
					continue
				End If
			End If

			'数値だったら数値解析ステートに移る
			if (str[ci] >= &H30 And str[ci] <= &H39) or _
				(base=16 And (str[ci] >= &H61 And str[ci] <= &H66)) Then					
				state++

				'固定基数なのに変わってたらアウト
				if fFixedBase And (base <> _base) Then Goto *rcATOI_ERRNUM
			Else 
				ci++
				continue
			End If
		End If

		'数値処理
		if state=1 Then
			if (str[ci] >= &H30 And str[ci] <= &H39) Then
				if (str[ci]-&H30) => base Then Goto *rcATOI_ERRNUM
				num=num * base
				num=num + str[ci]-&H30
			Elseif (base=16 And (str[ci] >= &H61 And str[ci] <= &H66)) Then
				num = num * base 
				num = num + str[ci]-&H61 +10 
			Else 
				state++
			Endif
		End If

		'SI 接頭辞処理
		if state=2 Then 
			Select Case str[ci]
				Case &H6B
					num*=siZoom
				Case &H6D
					num*=siZoom*siZoom
				Case &H67
					num*=siZoom*siZoom*siZoom
				Case &H74 
					num*=siZoom*siZoom*siZoom*siZoom
			End Select
			ci++
			state++
		End If

		if state=3 Then 
			if isSameBin(str+ci,"bit",3) Then
				num=num/8
			End If
			state++
		End If

		if state=4 Then ExitDo

		ci++

	Loop

	if fNegative Then	num*=-1
	printf(ex"str = %s\nfNegative = %d\nbase = %d\nnum = %d\nnum = 0x%X\nnum = %dK\n\n",str,fNegative,base,num,num,num/siZoom)

	rcAsciiToInt=TRUE
	SetDWord(result_num,num)
	ExitFunction

*rcATOI_ERRNUM
	rcAsciiToInt=FALSE
End Function

Sub MainWnd_CommandButton7_Click()

	Dim data As Byte,adr As DWord
	data=GetDlgItemHex(MWnd(EditBox3)) As Byte
	adr=GetDlgItemHex(MWnd(EditBox4))
	DBM("Write 0x"+Hex$(data)+" to 0x"+Hex$(adr))
/*	WriteROM(hCOM,VarPtr(data),0,adr,1, _
			NOT(GetCheckBox(MWnd(CheckBox6))) And &H01)*/
	SetCartRegister(adr>>16,adr And &HFFFF,data,	NOT(GetCheckBox(MWnd(CheckBox6))) And &H01)
	
End Sub

Const ST018_BIOS_SIZE = 160*1024 As DWord
Const ST018_BIOS_PRG_SIZE = 128*1024 As DWord
Const ST018_BIOS_DAT_SIZE =  32*1024 As DWord
Const ST018_BIOS_NAME_COMBINED = "st018.rom"
Const ST018_BIOS_NAME_PROGRAM  = "st018.program.rom"
Const ST018_BIOS_NAME_DATA     = "st018.data.rom"
Const ST018_CHECKSUM = &HEAE5DA

Sub MainWnd_CommandButton17_Click()
	Dim out AS File
	Dim buf AS BytePtr
	Dim pPath AS BytePtr
	Dim path aS FilePath
	Dim pc AS *ProgressCallback

	pPath=SaveDialogCalloc(ex"ST018 ROM Image File(*.rom)\0*.rom\0Binaly Image(*.bin)\0*.bin\0すべてのファイル(*.*)\0*.*\0\0","rom",ST018_BIOS_NAME_COMBINED)
	if pPath=NULL Then ExitSub
	path.SetPath(pPath)

	buf=calloc(ST018_BIOS_SIZE)
	pc=New ProgressCallback()

	DBMN("ST018 BIOS Dumping")

	'BIOSダンプ
	if ST018_BiosDump(hCOM,buf,pc)=FALSE Then
		ErrMes(hMainWnd,"st018.romの吸出しに失敗しました。","st018.rom dumping failed.",0)
		Goto *BIOSDUMP_EXIT
	End If

	Dim checksum AS DWord
	checksum=SnesCheckSum(buf,ST018_BIOS_SIZE)
	DBM(sprintfStr(ex"CheckSum  : %08X\r\nActualSum : %08X",ST018_CHECKSUM,checksum))
	if ST018_CHECKSUM=checksum Then
		DBM(ex"Checksum OK.\r\n")
		MessageBeep(MB_ICONASTERISK)
	Else
		DBM(ex"Checksum NG.\r\nデータが破損しています。\r\nリトライしてください。\r\n")
		MessageBeep(MB_ICONHAND)
	End If
	
	'PROGRAM+DATA結合データを出力（st018.rom）
	if out.openFile(path.GetPath(),GENERIC_WRITE)=FALSE Then
		DBM("I/Oエラー")
		Goto *BIOSDUMP_EXIT
	Endif
	out.write(buf,ST018_BIOS_SIZE)
	out.close()
	DBM(path.GetFileName())

	'st018.program.romを出力
	path.PopDir()
	path.PushFile(ST018_BIOS_NAME_PROGRAM)

	out.openFile(path.GetPath(),GENERIC_WRITE)
	out.write(buf,ST018_BIOS_PRG_SIZE)
	out.close()

	DBM(ST018_BIOS_NAME_PROGRAM)

	'st018.data.romを出力
	path.PopDir()
	path.PushFile(ST018_BIOS_NAME_DATA)

	out.openFile(path.GetPath(),GENERIC_WRITE)
	out.write(buf+ST018_BIOS_PRG_SIZE,ST018_BIOS_DAT_SIZE)
	out.close()
	DBM(ST018_BIOS_NAME_DATA)

	DBM(ex"saved.\r\n")

*BIOSDUMP_EXIT
	free(buf)
	delete pc
End Sub

Class ProgressCallback
Private
	Max AS Long
	Now AS Long
	hProgress As HANDLE
Public
	Sub Init(Max AS Word) 
		hProgress=MWnd(hProg)
		this.Now=0
		this.Max=Max

		SendMessage(hProgress, PBM_SETPOS, 0, 0 )
		SendMessage(hProgress, PBM_SETRANGE,0,MAKELONG(0,Max As Word))

		SetDlgEnable(STATUS_DUMPING)

	End Sub

	Sub Step(step AS Long)
		SendMessage(hProgress, PBM_SETSTEP,step,0)
		SendMessage(hProgress,PBM_STEPIT,0,0)

		Now = Now + step		
		SetWindowText(MWnd(Static7),sprintfStr("%d%%",Int(Now/Max*100)))

		DBMN(".")

		PumpMessage()
	End Sub

	Sub Final()
		SendMessage(hProgress, PBM_SETPOS, 0, 0 )

		SetWindowText(MWnd(Static7),"100%")

		SetDlgEnable(STATUS_CONNECTED)

		DBM(ex"\r\n")
	End Sub
End Class
