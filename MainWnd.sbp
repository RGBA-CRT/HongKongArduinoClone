'-----------------------------------------------------------------------------
'  イベント プロシージャ
'-----------------------------------------------------------------------------
' このファイルには、ウィンドウ [MainWnd] に関するイベントをコーディングします。
' ウィンドウ ハンドル: hMainWnd

' TODO: この位置にグローバルな変数、構造体、定数、関数を定義します。

Dim hCOM As HANDLE
Dim DlgStatus As DLG_STATUS
Dim fWindowActive AS BOOL


'ダイアログの状態
Enum DLG_STATUS
	STATUS_CONNECTED
	STATUS_DUMPING
	STATUS_CLOSED
End Enum

'-----------------------------------------------------------------------------
' ウィンドウメッセージを処理するためのコールバック関数

Function MainWndProc(hWnd As HWND, dwMsg As DWord, wParam As WPARAM, lParam As LPARAM) As DWord
	' TODO: この位置にウィンドウメッセージを処理するためのコードを記述します。

	'デバイス切断接続メッセージ
	If dwMsg=WM_DEVICECHANGE Then
		If DlgStatus=STATUS_CLOSED Then
			'接続されていなかったら
			ListUpComPort(GetDlgItem(hMainWnd,ComList))

		Else if DlgStatus=STATUS_CONNECTED Then
			'Arduinoが抜けてないかチェック
			If CheckFirmware(hCOM,FALSE)=FALSE Then
				DisconnectDevice()
				DBM("Device disconnected.")
			End If
		
		End If
	Else if dwMsg=WM_COMMAND then
		'アクセラレータキー経由だと、ActiveBasicのEventCallに引っかからないので、アクセラレータフラグを消す
		'printf(ex"WM_COMMAND nofty=%X %X\n",wParam>>16,lParam)
		If lParam=NULL Then wParam = wParam And &HFFFeFFFF

		'タブストップの処理（手動）
		If wParam=ID_DLG_TAB Then  
			SetFocus( GetNextDlgTabItem(hMainWnd,  GetFocus(), FALSE))
			ExitFunction
		End If
	End If
	' イベントプロシージャの呼び出しを行います。
	MainWndProc=EventCall_MainWnd(hWnd,dwMsg,wParam,lParam)
End Function

'-----------------------------------------------------------------------------
' ここから下は、イベントプロシージャを記述するための領域になります。
Function MWnd(DlgItem As Long) As HWND
	MWnd=GetDlgItem(hMainWnd,DlgItem)
End Function

Sub MainWnd_Destroy()
	If hCOM<>0 Then CloseHandle(hCOM)

	HongKongArduinoClone_DestroyObjects()
	PostQuitMessage(0)
End Sub

Sub ResetDBM()
	SetWindowText(MWnd(EditBox1),"")
	DBM(ProgramName+" "+VerStr+ex"\r\nProgrammed by RGBA_CRT 2018\r\nThis program was cloned \r\n	from WinHongKongArduino.\r\nCopyright (c) 2014 たにやま\r\n")
End Sub


Dim hFont_LogBox As HFONT
Sub MainWnd_Create(ByRef CreateStruct As CREATESTRUCT)
	ResetDBM()
	
	SetIniPath()

	ListUpComPort(GetDlgItem(hMainWnd, ComList))

	' setup mapper type list box
	Dim i as Long
	for i = 0 To SFC_MAP_TYPE__NUM-1
		SendMessage(MWnd(MAPPING), CB_ADDSTRING, 0, GetMappingString(i) As Long)
	Next i
	
	'SendMessage(MWnd(EditBox1), WM_SETFONT, CreateFont( -12, 0, 0, 0, 400, 0, 0, 0, SHIFTJIS_CHARSET, OUT_RASTER_PRECIS, 0, DEFAULT_QUALITY, FIXED_PITCH, "ＭＳ ゴシック") As DWord , TRUE)
	SendMessage(hMainWnd, WM_SETICON, ICON_SMALL, LoadImage(GetModuleHandle(0), IDI_ICON1 As BytePtr, IMAGE_ICON, GetSystemMetrics(SM_CXSMICON), GetSystemMetrics(SM_CYSMICON), LR_DEFAULTCOLOR) As Long)
	
	SetCheckBox(MWnd(CheckBox6), TRUE)
	
	SetDlgEnable(STATUS_CLOSED)
	
	Dim buf[100] AS Byte
	Dim tmp AS DWord
	For i = 0 To 7
		tmp = &H80 << i
		SendMessage(MWnd(ROM_SIZE), CB_ADDSTRING, 0, sprintfStr("%dKB [%dMbit]", (tmp) As DWord, (tmp * 8 / 1024) As DWord) )
		tmp = &H02 << i
		SendMessage(MWnd(SRAM_SIZE), CB_ADDSTRING, 0, sprintfStr("%dKB [%dKbit]", (tmp) As DWord, (tmp * 8) As DWord) )
	Next i
	
	Dim baudrate As DWord
	baudrate = GetPrivateProfileInt(ProgramName, "BaudRate", DEFAULT_BAUDRATE, INIFILE_PATH)
	If baudrate = 0 Then baudrate = DEFAULT_BAUDRATE
	
#IFDEF _DEBUG
	MoveWindow(hMainWnd, 0, 0, 505, 330, TRUE)
#endif
	
	SetWindowText(MWnd(EditBox6), Str$(baudrate))

	wsprintf(buf, "%s %s", ProgramName, VerStr)
	SetWindowText(hMainWnd, buf)

	hFont_LogBox=CreateFont(-12,0,0,0,400,0,0,0,128,3,2,1,50,"MS Gothic")
	SendMessage(GetDlgItem(hMainWnd,EditBox1),WM_SETFONT,hFont_LogBox As WPARAM,0)
End Sub

Sub SetIniPath()
	'INIファイルへのパスを記録
	Dim Path[MAX_PATH + 20] As Byte, i As Long
	
	'自己のファイルパスを取得
	GetModuleFileName(NULL, Path, MAX_PATH)
	For i = lstrlen(Path) To 0 Step -1
		If Path[i] = &H5C then ExitFor' \ だったら
	Next i
	Path[i + 1] = 0'￥以下を潰す
	
	INIFILE_PATH = calloc(lstrlen(Path) + Len(INIFILE_NAME) + 10)
	lstrcpy(INIFILE_PATH, Path)
	lstrcat(INIFILE_PATH, INIFILE_NAME)
End Sub


Sub ListUpComPort_Callback(userdata AS VoidPtr, PortName As BytePtr, FriendlyName AS BytePtr)
	Dim hCombobox As HWND
	hCombobox = userdata

	Dim textbuf[64] As BytePtr
	wsprintf(textbuf, ex"%s - %s",PortName,FriendlyName)

	PumpMessage()
	' Get Text Width
	Dim size As SIZE, hdc As HDC, hOldFont As HFONT, hNowFont As HFONT
	hdc = GetDC(hCombobox)
	hOldFont = SelectObject(hdc, hFont_MainWnd)
	GetTextExtentPoint32(hdc, textbuf, lstrlen(textbuf), size)
	ReleaseDC(hCombobox,hdc)

	' Adjust Dropdown list width
	Dim currentWidth AS Long
	currentWidth = 	SendMessage(hCombobox, CB_GETDROPPEDWIDTH, 0, 0)
	if currentWidth < size.cx Then SendMessage(hCombobox, CB_SETDROPPEDWIDTH, size.cx+10, 0)

	' add string
	SendMessage(hCombobox,CB_ADDSTRING,0,textbuf As Long)
Endsub

Sub ListUpComPort(Wnd As HWND)
	' デバイス名付きリストアップを試す(Win2K以降)
	Dim sa AS SetupApiWrapper
	if sa.Load() Then
		EnumSerialPorts(VarPtr(sa), AddressOf(ListUpComPort_Callback), Wnd)

	Else
		DBM("Cannot Load setupapi.dll")

		'旧リストアップ関数を呼び出し
		ListUpComPort_Win9x(Wnd)
	Endif

	'最後に選択されたポートを選ぶ
	Dim lastDevice aS BytePtr, lastDeviceIdx AS Long
	lastDevice=calloc(128)
	GetPrivateProfileString(ProgramName,"LastDevice","None",lastDevice,128,INIFILE_PATH)

	'探す
	lastDeviceIdx=SendMessage(Wnd,CB_FINDSTRINGEXACT,-1,lastDevice As DWord)
	If lastDeviceIdx=CB_ERR Then lastDeviceIdx=0

	'セットする
	SendMessage(Wnd,CB_SETCURSEL,lastDeviceIdx,0)
	 
	free(lastDevice)	
End Sub

Sub ListUpComPort_Win9x(Wnd As HWND)
	Dim buf As BytePtr,p As DWord,C As Long
	dim QDD_BUFSIZE As DWord

	QDD_BUFSIZE=GetPrivateProfileInt(ProgramName,"QDDSize",DEFAULT_QDD_BUFSIZE,INIFILE_PATH)
	If QDD_BUFSIZE<1024 Then 
		QDD_BUFSIZE=DEFAULT_QDD_BUFSIZE
		DBM("QDD size fixed.")
		WritePrivateProfileString(ProgramName,"QDDSize",Str$(QDD_BUFSIZE),INIFILE_PATH)
	End If

	SendMessage(Wnd,CB_RESETCONTENT,0,0)

	buf=calloc(QDD_BUFSIZE)
	If QueryDosDevice(NULL,buf,QDD_BUFSIZE) = 0 Then 
		SendMessage(Wnd,CB_ADDSTRING,0,"Error!" As Long)
		p=GetLastError()
		DBM(ex"COM Port Listup Error!\r\nCode."+Str$(p))
		If p=122 Then
			ErrMes(hMainWnd,ex"デバイスリストバッファのサイズが小さすぎます\n"+INIFILE_NAME+"を開き、QDDSizeの右辺の値を増やしてください。","QueryDosDevice Error",0)
		End If
		Goto *LUCP_EXIT
	End If	
	Do
		If win_strncmp(buf+p,"COM",3)=TRUE Then
			SendMessage(Wnd,CB_ADDSTRING,0,(buf+p) As Long)
			C++
		End If
		While buf[p]<>0
			p++
		WEnd
		p++
		If buf[p+1]=0 Then Exitdo	'ダブルNULLで終了
	Loop

*LUCP_EXIT
	free(buf)

	If C=0 then SendMessage(Wnd,CB_ADDSTRING,0,"None" As Long)


End Sub

Sub DBM(Text As BytePtr)
	Dim LastPos As DWord, hEB As HANDLE
	hEB = MWnd(EditBox1)
	LastPos = GetWindowTextLength(hEB)
	
	'10KBを超えてたらログをクリア
	If LastPos>1024 * 10 Then
		'1KB残す
		Dim txt AS BytePtr
		txt = calloc(LastPos + 1)
		GetWindowText(hEB, txt, LastPos)
		SetWindowText(hEB, txt + LastPos -1024)
		free(txt)
		LastPos = 1025
	End If
	
	SendMessage(hEB, EM_SETSEL, LastPos, LastPos)
	SendMessage(hEB, EM_REPLACESEL, 0, Text As Long)
	SendMessage(hEB, EM_REPLACESEL, 0, ex"\r\n" As Long)
	OutputDebugString(Text)
	OutputDebugString(ex"\r\n")
End Sub

Sub DBMN(Text As BytePtr)
	Dim LastPos As DWord, hEB As HANDLE
	hEB = MWnd(EditBox1)
	LastPos = GetWindowTextLength(hEB)
	SendMessage(hEB, EM_SETSEL, LastPos, LastPos)
	SendMessage(hEB, EM_REPLACESEL, 0, Text As Long)
End Sub


Sub MainWnd_CommandButton5_Click()
	'設定保存
	SaveIniFile()
	
	If hCOM = 0 then
		'接続
		Dim txCom As BytePtr, rate As DWord, i As Long
		
		rate = GetDlgItemInt(hMainWnd, EditBox6, NULL, FALSE)
		If rate = 0 Then
			ErrMes(hMainWnd, "ボーレートが不正です。", "Invalid baud rate", 0)
			ExitSub
		End If
		
		txCom = GetWndTextMalloc(GetDlgItem(hMainWnd, ComList))
		DBMN("Connect to "): DBM(txCom)
		for i=0 To 10
			if txCom[i] = 0 Then ExitFor
			if txCom[i] = &H20 Then
				txCom[i] = 0
				ExitFor
			End If
		Next i
		
		'bufferlen
		Dim bufferSize AS DWord
		bufferSize = GetPrivateProfileInt(ProgramName, "DumpBufferSize", DEFAULT_DUMP_SIZE, INIFILE_PATH)
		If bufferSize <= 0 Then bufferSize = DEFAULT_DUMP_SIZE
		
		'connect and reset ボーレート
		hCOM = OpenComPort(txCom, INITIAL_BAUDRATE, bufferSize, 1024 * 10)
		ResetArduino(hCOM)
		CloseHandle(hCOM)
		
		'reconnect, 接続を確立
		hCOM = OpenComPort(txCom, INITIAL_BAUDRATE, bufferSize, 1024 * 10)
		
		
		If hCOM = NULL Then
			ErrMes(hMainWnd, MakeStr(txCom) + ex"への接続に失敗しました。", "Connection failed", 0, GetLastError())
			DBM("Serial connection Failed.")
			hCOM = 0
			free(txCom)
			ExitSub
		Else
			DBM(ex"Connection Stage1 OK.\r\n")
		End If
		free(txCom)
		
		SetWindowText(MWnd(CommandButton5), "&Close")
		SetDlgEnable(STATUS_CONNECTED)
		
		'正常なデータ通信を確立(できるようになるまでリトライ）
		If CheckFirmware(hCOM, TRUE) = FALSE Then
			'	ErrMes(hMainWnd,"指定されたデバイスはHongKoongArduinoではありません。",0,0)
			goto * HKAF_CON_ERR
		End If
		DBM(ex"Connection Stage2 OK.\r\n")
		
		'ボーレート変更コマンド送信
		if rate <> INITIAL_BAUDRATE Then
			ChangeBaudrate(hCOM, rate)
			DBM("baudrate=" + Str$(rate) + "bps")
			
			'変更後の正常なデータ通信を確立
			DBM("changeing baudrate...")
			If CheckFirmware(hCOM, FALSE) = FALSE Then
				DBM("invailde baudrate")
				goto * HKAF_CON_ERR
			End If
		End If
		
		DBM(ex"Connection Successful!!!\r\n")
		
		'GetCartInfo
		MainWnd_CommandButton1_Click()
		
	Else
		'切断
		DisconnectDevice()		
	End If
	
	ExitSub
*HKAF_CON_ERR
	DisconnectDevice()
	SetWindowText(MWnd(SRAM_SIZE), "")
	SetWindowText(MWnd(ROM_SIZE), "")
	SetWindowText(MWnd(ROMTITLE), "")
	SetWindowText(MWnd(CART_CIPS), "")
	SetWindowText(MWnd(MAPPING), "")
End Sub

Sub DisconnectDevice()
	If hCOM = 0 Then ExitSub
	CloseHandle(hCOM)
	hCOM = 0
	SetWindowText(MWnd(CommandButton5), "&Connect")
	SetDlgEnable(STATUS_CLOSED)
	
	DBM(ex"Connection is closed.\r\n")
End Sub

Sub SetDlgEnable(Mode As DLG_STATUS)
	'ボタンの有効/無効セット
	
	Dim isEnable As Long
	If Mode = STATUS_CONNECTED Or Mode = STATUS_DUMPING then
		isEnable = FALSE
	Else Mode = STATUS_CLOSED Then
		isEnable = TRUE
	End If
	EnableWindow(MWnd(ComList), isEnable)
	EnableWindow(MWnd(EditBox6), isEnable)
	EnableWindow(MWnd(Static9), isEnable)
	EnableWindow(MWnd(Static10), isEnable)
	
	If Mode = STATUS_DUMPING Then isEnable = NOT(isEnable) And &H01
	
	EnableWindow(MWnd(CommandButton1), NOT(isEnable) And &H01)
	EnableWindow(MWnd(CommandButton2), NOT(isEnable) And &H01)
	EnableWindow(MWnd(CommandButton3), NOT(isEnable) And &H01)
	EnableWindow(MWnd(CommandButton4), NOT(isEnable) And &H01)
	EnableWindow(MWnd(CommandButton17), NOT(isEnable) And &H01)
	
	EnableWindow(MWnd(MAPPING), NOT(isEnable) And &H01)
	EnableWindow(MWnd(ROM_SIZE), NOT(isEnable) And &H01)
	EnableWindow(MWnd(SRAM_SIZE), NOT(isEnable) And &H01)
	EnableWindow(MWnd(CB_MANUAL), NOT(isEnable) And &H01)
	
	If Mode = STATUS_DUMPING Then
		EnableWindow(MWnd(CommandButton5), FALSE)
	Else
		EnableWindow(MWnd(CommandButton5), TRUE)
	End If
	
	DlgStatus = Mode
End Sub

Function GetWndTextMalloc(hWnd As HWND) As BytePtr
	'コントロールのテキスト取得
	Dim buf As BytePtr
	buf = calloc(GetWindowTextLength(hWnd) + 20)
	GetWindowText(hWnd, buf, GetWindowTextLength(hWnd) + 1)
	
	GetWndTextMalloc = buf
End Function

Sub MainWnd_KeyUp(KeyCode As Long, flags As Long)
'	DBM("PressKey:"+Hex$(KeyCode))
	Select Case KeyCode
		Case &H70 : SpeedTest()	'F1
		Case &H71 : CheckFirmware(hCOM,FALSE)	'F2
		Case &H74 : ListUpComPort(GetDlgItem(hMainWnd,ComList))
		Case &H78 : MainWnd_CommandButton12_Click()
		Case &H7A : MainWnd_CommandButton15_Click()
		Case &H7B : MainWnd_CommandButton13_Click()

		'(このメッセージはフォーカスが無い状態なので)TABキーが押されたら適当なボタンにフォーカスを当てる
		'Case VK_TAB : SetFocus( GetNextDlgTabItem(hMainWnd, 0, TRUE))
	End Select
End Sub

Sub SpeedTest()
	'Arduinoとの接続速度テスト
	Dim rd As BytePtr, mes[256] As Byte, total As DWord, lt As DWord, i As Long
	Const TEST_READ_SIZE = 1024 * 10
	DBM("Speedtest : Read " + Str$(TEST_READ_SIZE / 1024) + "KB*10")
	rd = calloc(TEST_READ_SIZE)
	total = 0
	lt = 0
	For i = 0 To 9
		lt = GetTickCount()
		ReadROM(hCOM, rd, 0, i * TEST_READ_SIZE, TEST_READ_SIZE, FALSE)
		total + = GetTickCount() - lt
		wsprintf(mes, ex"\t[%d]Time : %dms", i, GetTickCount() - lt)
		DBM(mes)
	Next i
	wsprintf(mes, ex"Total:%dms\r\nAverage:%dms\r\nSpeed : %dbyte/sec (%dKB/s)\r\n", total, total / 9, (TEST_READ_SIZE * 10) / (total / 1000), (TEST_READ_SIZE * 10) / (total / 1000) / 1000)
	DBM(mes)
	free(rd)
End Sub



Sub MainWnd_CommandButton2_Click()
	'ROM吸出しボタン

	Dim info As SFC_CART_INFO
	Dim path As BytePtr

	GetDumpConfig(info)
'	info.RomSize = &H400000	'debug

#ifndef _DEBUG
	path=SaveDialogCalloc(ex"SFC ROMイメージファイル(*.sfc)\0*.sfc\0すべてのファイル(*.*)\0*.*\0\0", "sfc", info.Title)
	If path=0 Then ExitSub
#else
	path="dump.sfc"
#endif

	DumpFullROM(VarPtr(info), path)

#ifndef _DEBUG
	free(path)
#endif

	MessageBeep(MB_ICONASTERISK)
End Sub

Sub MainWnd_QueryClose(ByRef cancel As Integer)
	SaveIniFile()
End Sub

Sub SaveIniFile()
	Dim ratestr As BytePtr, Tmp As DWord
	
	ratestr = GetWndTextMalloc(MWnd(EditBox6))
	WritePrivateProfileString(ProgramName, "BaudRate", ratestr, INIFILE_PATH)
	free(ratestr)
	
	ratestr = GetWndTextMalloc(MWnd(ComList))
	WritePrivateProfileString(ProgramName, "LastDevice", ratestr, INIFILE_PATH)
	free(ratestr)
	
	Tmp = GetPrivateProfileInt(ProgramName, "MaxContinue", DEFAULT_CONTINUE, INIFILE_PATH)
	WritePrivateProfileString(ProgramName, "MaxContinue", Str$(Tmp), INIFILE_PATH)
	
	Tmp = GetPrivateProfileInt(ProgramName, "QDDSize", DEFAULT_QDD_BUFSIZE, INIFILE_PATH)
	If Tmp = 0 Then Tmp = DEFAULT_QDD_BUFSIZE
	WritePrivateProfileString(ProgramName, "QDDSize", Str$(Tmp), INIFILE_PATH)
	
	Tmp = GetPrivateProfileInt(ProgramName, "DumpBufferSize", DEFAULT_DUMP_SIZE, INIFILE_PATH)
	If Tmp <= 0 Then Tmp = DEFAULT_DUMP_SIZE
	WritePrivateProfileString(ProgramName, "DumpBufferSize", Str$(Tmp), INIFILE_PATH)
	
	WritePrivateProfileString(ProgramName, "RxTimeoutMargine", Str$(HKAC_RX_TIMEOUT_MARGIN), INIFILE_PATH)
End Sub

Sub MainWnd_CommandButton3_Click()
	Dim info As SFC_CART_INFO
	Dim path As BytePtr

	GetDumpConfig(info)
#ifndef _DEBUG
	path=SaveDialogCalloc(ex"SRAMイメージファイル(*.srm)\0*.srm\0すべてのファイル(*.*)\0*.*\0\0","srm",info.Title)
	If path=0 Then ExitSub
#else
	path="dump.srm"
#endif

	DumpSRAM(hCOM, VarPtr(info), path)
#ifndef _DEBUG
	free(path)
#endif
	MessageBeep(MB_ICONASTERISK)

End Sub

Sub MainWnd_CommandButton4_Click()
	Dim path As BytePtr
	
	Dim info As SFC_CART_INFO
	GetDumpConfig(info)
	
	If info.isFlashSave Then
		ErrMes(hMainWnd, "フラッシュメモリ方式のセーブデータ書き込みは現在未実装です。", "未実装", 0)
		If GetKeyState(VK_ESCAPE) And &H80 = 0 Then exitsub
	End If
	
#ifndef _DEBUG
	path = LoadDialogCalloc(ex"SRAMイメージファイル(*.srm)\0*.srm\0すべてのファイル(*.*)\0*.*\0\0", "srm")
	If path = 0 Then ExitSub
#else
	If GetKeyState(VK_ESCAPE) And &H80 Then
		path = LoadDialogCalloc(ex"SRAMイメージファイル(*.srm)\0*.srm\0すべてのファイル(*.*)\0*.*\0\0", "srm")
	Else
		path = "write.srm"
	End If
#endif

	If MessageBox(hMainWnd, ex"セーブデータが上書きされます。\nまた、正常に書き込める保障はありません。\n続行しますか？", ProgramName+" - SRAM write", MB_YESNO or MB_ICONWARNING) = IDNO Then ExitSub
	WriteSRAM(hCOM, VarPtr(info), path)

#ifndef _DEBUG
	free(path)
#endif

	MessageBeep(MB_ICONASTERISK)
End Sub

Function SaveDialogCalloc(filter As BytePtr, ext As String)(defFileName As BytePtr) As BytePtr
	Dim tOfn As OPENFILENAME, i As DWord
	
	'ファイルオープン構造体の初期化
	tOfn.lStructSize = SizeOf(OPENFILENAME) - SizeOf(DWord) * 2 - SizeOf(VoidPtr)
	tOfn.hwndOwner = hMainWnd
	tOfn.lpstrFilter = filter'ex"wavファイル(*.wav)\0*.wav\0すべてのファイル(*.*)\0*.*\0\0"'StrPtr(sFilter)
	tOfn.nFilterIndex = 1
	tOfn.nMaxFile = MAX_PATH
	tOfn.Flags = OFN_OVERWRITEPROMPT
	tOfn.lpstrDefExt = StrPtr(ext)'"wav"
	tOfn.lpstrFile = calloc(MAX_PATH + 10)
	If defFileName<>0 Then lstrcpy(tOfn.lpstrFile, defFileName)
	
	'ファイルオープンダイアログを表示する
	If GetSaveFileName(tOfn) = 0 Then
		ExitFunction
	End If
	
	SaveDialogCalloc = calloc(lstrlen(tOfn.lpstrFile) + 1)
	lstrcpy(SaveDialogCalloc, tOfn.lpstrFile)
	free(tOfn.lpstrFile)
End Function

Function LoadDialogCalloc(filter As BytePtr, ext As String) As BytePtr
	Dim tOfn As OPENFILENAME, i As DWord
	
	'ファイルオープン構造体の初期化
	tOfn.lStructSize = SizeOf(OPENFILENAME) - SizeOf(DWord) * 2 - SizeOf(VoidPtr)
	tOfn.hwndOwner = hMainWnd
	tOfn.lpstrFilter = filter'ex"wavファイル(*.wav)\0*.wav\0すべてのファイル(*.*)\0*.*\0\0"'StrPtr(sFilter)
	tOfn.nFilterIndex = 1
	tOfn.nMaxFile = MAX_PATH
	tOfn.Flags = OFN_OVERWRITEPROMPT
	tOfn.lpstrDefExt = StrPtr(ext)'"wav"
	tOfn.lpstrFile = calloc(MAX_PATH + 10)
	
	'ファイルオープンダイアログを表示する
	If GetOpenFileName(tOfn) = 0 Then
		ExitFunction
	End If
	
	LoadDialogCalloc = calloc(lstrlen(tOfn.lpstrFile) + 1)
	lstrcpy(LoadDialogCalloc, tOfn.lpstrFile)
	free(tOfn.lpstrFile)
End Function

Sub MainWnd_RButtonDblClick(flags As Long, x As Integer, y As Integer)
	ResetDBM()
	DBM("Cleared Log.")
End Sub

Sub MainWnd_Static1_DblClick()
	exec("http://susumutaniyama.github.io/HongKongArduino/")
End Sub

'リードテスト
Sub MainWnd_CommandButton6_Click()
	If hCOM = 0 Then ExitSub
	Dim data As BytePtr, adr As DWord
	data = calloc(&H10000)
	adr = GetDlgItemHex(MWnd(EditBox2))
	DBM("Dump 0x" + Hex$(adr))
	
	ReadROM(hCOM, data, 0, adr, &h5000, NOT(GetCheckBox(MWnd(CheckBox6))) And &H01)
	Dim f As File
	f.openFile("test.bin", GENERIC_WRITE)
	f.write(data, &h5000)
	f.close()
	DBM("OK")
	Dim p As BytePtr, i As Long
	p = data + &H5000
	For i = 0 To 7
		p + = wsprintf(p, "%02X ", data[i])
	Next i
	p + = wsprintf(p, ex"\r\n", data[i])
	For i = 0 To 7
		p + = wsprintf(p, "[%c]", data[i])
	Next i
	DBM(data + &H5000)
	Dump(data, 128)
End Sub

Sub MainWnd_MButtonDblClick(flags As Long, x As Integer, y As Integer)
	'ESC+マウス中ボタンダブルクリックでテストモード
	If GetCancelKey() Then 
		MoveWindow(hMainWnd,0,0,505,330,TRUE)
		AllocConsole()
		_System_hConsoleOut=GetStdHandle(STD_OUTPUT_HANDLE)
		printf(ex"Welcome to debug console\n")
	End If

End Sub



Sub MainWnd_CommandButton8_Click()
	If hCOM=0 Then ExitSub
	Dim ctrl As Byte
	ctrl=(GetCheckBox(MWnd(CheckBox2))<<3 or GetCheckBox(MWnd(CheckBox3))<<2 or _
		GetCheckBox(MWnd(CheckBox4))<<1 or GetCheckBox(MWnd(CheckBox5))) As Byte
	DBM("SetCtrlBus : 0"+Hex$(ctrl))

	SendControl(hCOM,ctrl)
End Sub

Sub MainWnd_CommandButton9_Click()
	DBM("回路デバッグモード")
	DBM("ESCキーで抜ける")
	Do
		MainWnd_CommandButton1_Click()
		Sleep(300)
		PumpMessage()
		If GetKeyState(VK_ESCAPE) And &H80 Then ExitDo
	Loop
End Sub

Sub MainWnd_CommandButton1_Click()
	SetRomInfoToDlg_FromROM()
End Sub

Sub SetRomInfoToDlg_FromROM()
	Dim buf[SFC_SPEC_HEADER_SIZE+2] As Byte,cartInfo As SFC_CART_INFO
	'DBM( "Cartridge Infomation")

	'ヘッダを読み出し＆ダイアログに情報を表示
	FlushCom(hCOM)
	getCartInfo(cartInfo)

	'ダイアログに表示
	SetCartInfo(VarPtr(cartInfo))

	Dim info_text[1024] as Byte
	GenerateHeaderInfoText(VarPtr(cartInfo), info_text, 1024)
	DBMN(info_text)
	
	'Manualのチェックを外す
	SetCheckBox(MWnd(CB_MANUAL),FALSE)

	'BSスロットがあればBSMWndを出す
	If cartInfo.isBSX Then
		BSM_open()

		Dim idx AS Long
		If cartInfo.Chipset=&HE5 Then
			idx=BSM_SLOT_BIOS
		Elseif cartInfo.MapType=SFC_MAP_LoROM or cartInfo.MapType=SFC_MAP_SpLoROM then
			idx=BSM_SLOT_SpLoROM
		Elseif cartInfo.MapType=SFC_MAP_HiROM then
			idx=BSM_SLOT_HiROM
		Elseif cartInfo.MapType=SFC_MAP_SA1 then
			idx=BSM_SLOT_SA1
		Else
			DBM("[!!!]Warning: unknown BS-X slot")
		End If
	'	debug
		SendMessage(BSMWnd(BSM_CT),CB_SETCURSEL,idx,0)
		PumpMessage()
	Else
		BSM_close()
	End If
	
	If cartInfo.MapType=SFC_MAP_SF_MENU Then
		SFM_open()
	End If	

	SetCheckBox(MWnd(CheckBox7),hasClockModule(hCOM))

	'アクセスランプをLow
	SetAddress(hCOM,&H000000,FALSE)
End Sub



Sub MainWnd_CommandButton10_Click()
	SPC7110_PrintBanks(hCOM)
	SPC7110_SetBanks(hCOM,0,TRUE)
	SPC7110_PrintBanks(hCOM)
	SPC7110_SetBanks(hCOM,0,FALSE)
	SPC7110_PrintBanks(hCOM)
End Sub


'---------------------------------------------------------------------------------------------------


'吸出し設定をROMとGUIから読み出し
Sub GetDumpConfig(ByRef info As SFC_CART_INFO)
	getCartInfo(info)

	GetDlgOption(info)	'infoにGUIの設定を反映

	SetCartInfo(VarPtr(info))
End Sub


Sub getCartInfo(ByRef info As SFC_CART_INFO)
	'カートリッジからヘッダをロード
	Dim buf[SFC_SPEC_HEADER_SIZE+5] As Byte
	/*ReadROM(hCOM,buf, 0, SFC_SPEC_HEADER_ADDR, SFC_SPEC_HEADER_SIZE,FALSE)
	SloveCartInfo(buf As *SFC_CART_HEADER,VarPtr(info))*/
	
'	SetCPU_Clock(hCOM,HKAC_CLOCK_NORMAL)	'clock
	SendControl(hCOM,DEFAULT_CTRLBUS)	'default

	If ReadROM(hCOM,buf, 0, SFC_SPEC_HEADER_ADDR, SFC_SPEC_HEADER_SIZE,FALSE)<SFC_SPEC_HEADER_SIZE Then
		lstrcpy(info.Title,"[ERR]通信エラー")
		SetCartInfo(VarPtr(info))
		ErrMes(hMainWnd,ex"通信エラーが発生しました。\nArduinoをリセットしてください。","Device was lost",0)
		DisconnectDevice()
		ExitSub
	End If
	SloveCartInfo(buf As *SFC_CART_HEADER,VarPtr(info))
End Sub

Function getSelectedMapMode() AS Long
	Dim idx AS Long
	idx=SendMessage(MWnd(MAPPING),CB_GETCURSEL,0,0) Mod SFC_MAP_TYPE__NUM
	if idx<0 or idx>=SFC_MAP_TYPE__NUM Then
		DBM("!!!!ASSERT, idx is over.")
		idx=0
	End If
	getSelectedMapMode=idx

End Function
Sub GetDlgOption(ByRef info As SFC_CART_INFO)
	'LoROM/HiROMの選択とMAD1のチェック取得
	If GetCheckBox(MWnd(CB_MANUAL)) Then
		info.MapType = getSelectedMapMode()
		'		info.MapMode = (info.MapMode And &HF0) or info.MapType
		info.RomSize = HKAC_GetWindowInt(MWnd(ROM_SIZE))
		info.SramSize = HKAC_GetWindowInt(MWnd(SRAM_SIZE))
		printf(ex"custom rom size = %d\n", (info.RomSize / 1024 / 1024) AS DWord)
		
		If info.MapType = SFC_MAP_LoROM or info.MapType = SFC_MAP_SpLoROM or info.MapType = SFC_MAP_SF_MENU Then
			info.AddrOffset = 0
			info.isLoROM = TRUE
		Else
			info.AddrOffset = HiROM_START_ADR
			info.isLoROM = FALSE
		End If
		
	End If
 End Sub

'MapMode (20 SrowRom LoROMのやつ）のGUI用関数
Function MapModeToComboboxIndex(mapMode As SFC_MAP_TYPE) As Long
	MapModeToComboboxIndex = mapMode As Long
End Function



'カートリッジ情報をGUIに反映
Sub SetCartInfo(info As *SFC_CART_INFO)
	'このルーチンからはManualのチェックが変わらないようにする
	Dim bManual AS BOOL
	bManual=GetCheckBox(MWnd(CB_MANUAL))

	SetWindowText(MWnd(ROMTITLE),info->Title)
	SendMessage(MWnd(MAPPING),CB_SETCURSEL,MapModeToComboboxIndex(info->MapType),0)
	MainWnd_MAPPING_SelChange()

	SetWindowText(MWnd(CART_CIPS), GetChipsetString(info))
	
	If info->RomSize =0 Then
		SetWindowText(MWnd(ROM_SIZE),"None")		
	Else
		SetWindowText(MWnd(ROM_SIZE),sprintfStr("%dKB [%dMbit]",
							(info->RomSize/1024) As DWord, (info->RomSize*8/(1024^2)) As DWord))
	End If
	If info->SramSize =0 Then
		SetWindowText(MWnd(SRAM_SIZE),"None")		
	Else
		Dim FLASH_TEXT AS BytePtr
		If info->isFlashSave Then
			FLASH_TEXT="[FLASH]"
		Else
			FLASH_TEXT=""
		End If
		SetWindowText(MWnd(SRAM_SIZE),sprintfStr("%dKB [%dKbit]%s",
			(info->SramSize/1024) As DWord, (info->SramSize*8/1024) As DWord, FLASH_TEXT As DWord))
	End If

	SetCheckBox(MWnd(CB_MANUAL),bManual)

End Sub	

Function GetCheckBox(Ctrl As HWND) As Byte
	If SendMessage(Ctrl,BM_GETCHECK,0,0) = BST_CHECKED then
		GetCheckBox=TRUE
	Else
		GetCheckBox=FALSE
	End If
End Function

Function SetCheckBox(Ctrl As HWND,bValue As BOOL) As Byte
	SendMessage(Ctrl,BM_SETCHECK,bValue,bValue)
End Function


Sub MainWnd_CheckBox6_Click()

End Sub

Sub RomCommand(Adr As DWord,val As DWord)
	Dim loAdr As DWord,tmp As DWord
	loAdr=&H8000 or (Adr And &H7FFF) or (Adr And &HFF8000)<<1
	DBM("CMD:"+Hex$(loAdr)+":"+Hex$(val))
	WriteROM(hCOM,VarPtr(val),0,Adr,1,TRUE)
End Sub

Sub MainWnd_CommandButton11_Click()
/*	Dim buf[20+512] As Byte
	RomCommand(BSX_MEMPACK_ADR_LoROM,&H38)
	RomCommand(BSX_MEMPACK_ADR_LoROM,&HD0)
	RomCommand(BSX_MEMPACK_ADR_LoROM,&H71)
	ReadROM(hCOM,buf,0,BSX_MEMPACK_ADR_LoROM,1,TRUE)
	DBM(Hex$(buf[0]))
	Sleep(50)
	ReadROM(hCOM,buf,0,BSX_MEMPACK_ADR_LoROM,1,TRUE)
	DBM(Hex$(buf[0]))
	RomCommand(BSX_MEMPACK_ADR_LoROM,&H72)
	RomCommand(BSX_MEMPACK_ADR_LoROM,&H75)
	ReadROM(hCOM,buf,0,BSX_MEMPACK_ADR_LoROM+&HFF00,20,TRUE)
	Dim p As BytePtr,i As Long
	p=buf+30
	For i=0 To 20
		p+=wsprintf(p,"%02X ",buf[i])
	Next i
	p+=wsprintf(p,ex"\r\n",buf[i])
	For i=0 To 20
		p+=wsprintf(p,"[%c]",buf[i])
	Next i
	p+=wsprintf(p,ex"\r\n",buf[i])
	p+=wsprintf(p,ex"\r\n",buf[i])
	DBM(buf+30)

	DBM(buf)
*/
	BSM_open()

End Sub

/*
Function Lo2Hi(Adr As DWord) As DWord
	Lo2Hi = (Adr And &HFF8000)<<1 or (Adr And &H007FFF) or &H8000
	
End Function
*/

Sub MainWnd_DropFiles(hDrop As HDROP)
	Dim buf[MAX_PATH] As Byte
	Dim i as long
	
	DBM("ROM File Infomation : ")
	Do
		If DragQueryFile(hDrop, i, buf, MAX_PATH) = 0 Then Exit Do
		i++
	Loop
	DragFinish(hDrop)
	
	Dim file AS File, header As SFC_CART_HEADER, cartInfo AS SFC_CART_INFO
	If file.openFile(buf, GENERIC_READ) = FALSE Then ExitSub
	
	'ヘッダ位置候補 HiROM,LoROM,HiROM(ヘッダ付き),LoROM(ヘッダ付き)
	Dim headerAdrs[4] = [&HFFB0, &H7FB0, &HFFB0 + &H200, &H7FB0 + &H200] AS DWord
	For i = 0 To 3
		file.setFilePtr(headerAdrs[i])
		file.read(VarPtr(header), SFC_SPEC_HEADER_SIZE)
		
		If isSnesHeader(VarPtr(header)) = TRUE Then ExitFor
	Next i
	
	file.close()
	
	If isSnesHeader(VarPtr(header)) = FALSE Then
		DBM(ex"ROM Header not found!\r\n")
		MessageBeep(MB_ICONEXCLAMATION)
		ExitSub
	Else
		DBM("Found header at 0x" + Hex$(headerAdrs[i]))
	End If
	
	SloveCartInfo(VarPtr(header), VarPtr(cartInfo))
	SetCartInfo(VarPtr(cartInfo))

	Dim infotext[HEADER_INFO_TEXT_LEN] As Byte
	GenerateHeaderInfoText(VarPtr(cartInfo), infotext, HEADER_INFO_TEXT_LEN)
	DBM(infotext)
End Sub


'これやるとOSとデバイス間の通信も切れる

Sub ResetArduino(hCOM AS HANDLE)
	EscapeCommFunction(hCOM, SETDTR)
	Sleep(50)
	EscapeCommFunction(hCOM, CLRDTR)
	Sleep(50)
End Sub


Sub MainWnd_CommandButton12_Click()
	DBM("CPU CLOCK OVERCLOCKED")
	SetCPU_Clock(hCOM, HKAC_CLOCK_CPU_OVERCLOCKED)
	
End Sub

Sub MainWnd_CommandButton15_Click()
	MainWnd_CommandButton17_Click()
End Sub

Sub MainWnd_CommandButton13_Click()
	DBM("CPU CLOCK DISABLE")
	SetCPU_Clock(hCOM, HKAC_CLOCK_DISABLED)
End Sub

Sub MainWnd_CommandButton14_Click()
	SFM_open()
End Sub

Dim MW_bMove AS BOOL

Sub MainWnd_Move(x As Integer, y As Integer)
	If MW_bMove = TRUE Then ExitSub
	
	If hSFMem<>NULL then
		MoveChildWindow(hMainWnd, hSFMem)
	End If
	If hBSMem<>NULL Then
		MoveChildWindow(hMainWnd, hBSMem)
	End If
End Sub

Sub MoveChildWindow(owner AS HWND, child AS HWND)
	Dim rect aS RECT
	GetWindowRect(owner, rect)
	rect.right = rect.right + GetSystemMetrics(SM_CXSIZEFRAME) * 2'10
	'面白い挙動するので残しておく
	'SetWindowPos(hSFMem,NULL,rect.top,rect.right,0,0,SWP_NOSIZE or SWP_SHOWWINDOW)
	
	MW_bMove = TRUE
	SetWindowPos(child, NULL, rect.right, rect.top, 0, 0, SWP_NOSIZE or SWP_NOZORDER or SWP_NOOWNERZORDER or SWP_NOACTIVATE)
	MW_bMove = FALSE
End Sub


Sub MainWnd_MAPPING_SelChange()
	Dim SelectedMapMode AS Long
	SelectedMapMode = getSelectedMapMode()
	
	If SelectedMapMode = SFC_MAP_SF_MENU Then
		ShowWindow(MWnd(CommandButton14), SW_SHOW)
	Else
		ShowWindow(MWnd(CommandButton14), SW_HIDE)
	End If
	
	If SelectedMapMode = SFC_MAP_ST018 Then
		ShowWindow(MWnd(CommandButton17), SW_SHOW)
	Else
		ShowWindow(MWnd(CommandButton17), SW_HIDE)
	End If
	
	
	'いじったらマニュアルチェックを付ける
	SetCheckBox(MWnd(CB_MANUAL), TRUE)
End Sub

Sub MainWnd_CheckBox1_Click()
	
End Sub

Function GetCancelKey() AS BOOL
	If (GetKeyState(VK_ESCAPE) And &H80) And (fWindowActive = TRUE) Then
		GetCancelKey = TRUE
	Else
		GetCancelKey = FALSE
	End If
End Function

Sub MainWnd_Activate(state As Integer, minimized As Integer)
	If state = WA_INACTIVE Then
		fWindowActive = FALSE
	Else
		fWindowActive = TRUE
	End If
End Sub

Sub MainWnd_CommandButton16_Click()
	SetDlgEnable(STATUS_CONNECTED)
End Sub

Sub MainWnd_ROM_SIZE_SelChange():	SetCheckBox(MWnd(CB_MANUAL),TRUE):	End Sub
Sub MainWnd_SRAM_SIZE_SelChange():	SetCheckBox(MWnd(CB_MANUAL),TRUE):	End Sub
Sub MainWnd_ROM_SIZE_EditChange():	SetCheckBox(MWnd(CB_MANUAL),TRUE):	End Sub
Sub MainWnd_SRAM_SIZE_EditChange():	SetCheckBox(MWnd(CB_MANUAL),TRUE):	End Sub
Sub MainWnd_MAPPING_EditChange():	SetCheckBox(MWnd(CB_MANUAL),TRUE):	End Sub

Function HKAC_GetWindowInt(hWnd AS HWND) AS Long
	Dim str AS BytePtr
	str=GetWndTextMalloc(hWnd)
	rcAsciiToInt(str,VarPtr(HKAC_GetWindowInt),0,TRUE)
	free(str)
End Function



Sub MainWnd_CommandButton7_Click()

	Dim data As Byte,adr As DWord
	data=GetDlgItemHex(MWnd(EditBox3)) As Byte
	adr=GetDlgItemHex(MWnd(EditBox4))
	DBM("Write 0x"+Hex$(data)+" to 0x"+Hex$(adr))
/*	WriteROM(hCOM,VarPtr(data),0,adr,1, _
			NOT(GetCheckBox(MWnd(CheckBox6))) And &H01)*/
	SetCartRegister((adr>>16) As Byte,(adr And &HFFFF) AS Word,data,	NOT(GetCheckBox(MWnd(CheckBox6))) And &H01)
	
End Sub

Const ST018_BIOS_SIZE = 160*1024 As DWord
Const ST018_BIOS_PRG_SIZE = 128*1024 As DWord
Const ST018_BIOS_DAT_SIZE =  32*1024 As DWord
Const ST018_BIOS_NAME_COMBINED = "st018.rom"
Const ST018_BIOS_NAME_PROGRAM  = "st018.program.rom"
Const ST018_BIOS_NAME_DATA	 = "st018.data.rom"
Const ST018_CHECKSUM = &HEAE5DA

Sub MainWnd_CommandButton17_Click()
	Dim out AS File
	Dim buf AS BytePtr
	Dim pPath AS BytePtr
	Dim path aS FilePath
	Dim pc AS * ProgressCallback
	
	pPath = SaveDialogCalloc(ex"ST018 ROM Image File(*.rom)\0*.rom\0Binaly Image(*.bin)\0*.bin\0すべてのファイル(*.*)\0*.*\0\0", "rom", ST018_BIOS_NAME_COMBINED)
	If pPath = NULL Then ExitSub
	path.SetPath(pPath)
	
	buf = calloc(ST018_BIOS_SIZE)
	pc = New ProgressCallback()
	
	DBMN("ST018 BIOS Dumping")
	
	'BIOSダンプ
	If ST018_BiosDump(hCOM, buf, pc) = FALSE Then
		ErrMes(hMainWnd, "st018.romの吸出しに失敗しました。", "st018.rom dumping failed.", 0)
		Goto * BIOSDUMP_EXIT
	End If
	
	Dim checksum AS DWord
	checksum = SnesCheckSum(buf, ST018_BIOS_SIZE)
	DBM(sprintfStr(ex"CheckSum  : %08X\r\nActualSum : %08X", ST018_CHECKSUM, checksum))
	If ST018_CHECKSUM = checksum Then
		DBM(ex"Checksum OK.\r\n")
		MessageBeep(MB_ICONASTERISK)
	Else
		DBM(ex"Checksum NG.\r\nデータが破損しています。\r\nリトライしてください。\r\n")
		MessageBeep(MB_ICONHAND)
	End If
	
	'PROGRAM+DATA結合データを出力（st018.rom）
	If out.openFile(path.GetPath(), GENERIC_WRITE) = FALSE Then
		DBM("I/Oエラー")
		Goto * BIOSDUMP_EXIT
	End If
	out.write(buf, ST018_BIOS_SIZE)
	out.close()
	DBM(path.GetFileName())
	
	'st018.program.romを出力
	path.PopDir()
	path.PushFile(ST018_BIOS_NAME_PROGRAM)
	
	out.openFile(path.GetPath(), GENERIC_WRITE)
	out.write(buf, ST018_BIOS_PRG_SIZE)
	out.close()
	
	DBM(ST018_BIOS_NAME_PROGRAM)
	
	'st018.data.romを出力
	path.PopDir()
	path.PushFile(ST018_BIOS_NAME_DATA)
	
	out.openFile(path.GetPath(), GENERIC_WRITE)
	out.write(buf + ST018_BIOS_PRG_SIZE, ST018_BIOS_DAT_SIZE)
	out.close()
	DBM(ST018_BIOS_NAME_DATA)
	
	DBM(ex"saved.\r\n")
	
*BIOSDUMP_EXIT
	free(buf)
	delete pc
End Sub

Class ProgressCallback
Private
	Max AS Long
	Now AS Long
	hProgress As HANDLE
Public
	Sub Init(Max AS Word) 
		hProgress=MWnd(hProg)
		this.Now=0
		this.Max=Max

		SendMessage(hProgress, PBM_SETPOS, 0, 0 )
		SendMessage(hProgress, PBM_SETRANGE,0,MAKELONG(0,Max As Word))

		SetDlgEnable(STATUS_DUMPING)

	End Sub

	Sub Step(step AS Long)
		SendMessage(hProgress, PBM_SETSTEP,step,0)
		SendMessage(hProgress,PBM_STEPIT,0,0)

		Now = Now + step		
		SetWindowText(MWnd(Static7),sprintfStr("%d%%",Int(Now/Max*100)))

		DBMN(".")

		PumpMessage()
	End Sub

	Sub Final()
		SendMessage(hProgress, PBM_SETPOS, 0, 0 )

		SetWindowText(MWnd(Static7),"100%")

		SetDlgEnable(STATUS_CONNECTED)

		DBM(ex"\r\n")
	End Sub
End Class

Sub MainWnd_CommandButton18_Click()   
	Dim size As SIZE
	Dim hdc As HDC, hWnd AS HWND
	hWnd=MWnd(ComList)
	hdc = GetDC(hWnd)
	Dim text AS BytePtr
	text = "tあいうえおかんじ感じ"
	GetTextExtentPoint32(hdc, text, lstrlen(text), size)
	ReleaseDC(hWnd,hdc)

	printf("size: %d,%d", size.cx, size.cy)

	Dim currentWidth AS Long
	currentWidth = 	SendMessage(MWnd(ComList), CB_GETDROPPEDWIDTH, 0, 0)
	if currentWidth < size.cx Then SendMessage(MWnd(ComList), CB_SETDROPPEDWIDTH, size.cx, 0)
	SendMessage(MWnd(ComList), CB_ADDSTRING, 0, text)
End Sub
