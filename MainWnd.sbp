'-----------------------------------------------------------------------------
'  イベント プロシージャ
'-----------------------------------------------------------------------------
' このファイルには、ウィンドウ [MainWnd] に関するイベントをコーディングします。
' ウィンドウ ハンドル: hMainWnd

' TODO: この位置にグローバルな変数、構造体、定数、関数を定義します。

Dim hCOM As HANDLE
Dim DlgStatus As DLG_STATUS
Dim fWindowActive AS BOOL

Dim isFirstBaudrateError=FALSE As BOOL

'ダイアログの状態
Enum DLG_STATUS
	STATUS_CONNECTED
	STATUS_DUMPING
	STATUS_CLOSED
End Enum

'-----------------------------------------------------------------------------
' ウィンドウメッセージを処理するためのコールバック関数

Function MainWndProc(hWnd As HWND, dwMsg As DWord, wParam As WPARAM, lParam As LPARAM) As DWord
	' TODO: この位置にウィンドウメッセージを処理するためのコードを記述します。

	'デバイス切断接続メッセージ
	If dwMsg=WM_DEVICECHANGE Then
		If DlgStatus=STATUS_CLOSED Then
			'接続されていなかったら
			ListUpComPort(GetDlgItem(hMainWnd,ComList))

		Else if DlgStatus=STATUS_CONNECTED Then
			'Arduinoが抜けてないかチェック
			If CheckFirmware(hCOM,FALSE)=FALSE Then
				DisconnectDevice()
				DBM("Device disconnected.")
			End If
		
		End If
	Else if dwMsg=WM_COMMAND then
		'アクセラレータキー経由だと、ActiveBasicのEventCallに引っかからないので、アクセラレータフラグを消す
		'printf(ex"WM_COMMAND nofty=%X %X\n",wParam>>16,lParam)
		If lParam=NULL Then wParam = wParam And &HFFFeFFFF

		'タブストップの処理（手動）
		If wParam=ID_DLG_TAB Then  
			SetFocus( GetNextDlgTabItem(hMainWnd,  GetFocus(), FALSE))
			ExitFunction
		End If
	End If
	' イベントプロシージャの呼び出しを行います。
	MainWndProc=EventCall_MainWnd(hWnd,dwMsg,wParam,lParam)
End Function

'-----------------------------------------------------------------------------
' ここから下は、イベントプロシージャを記述するための領域になります。
Function MWnd(DlgItem As Long) As HWND
	MWnd=GetDlgItem(hMainWnd,DlgItem)
End Function

Sub MainWnd_Destroy()
	If hCOM<>0 Then CloseHandle(hCOM)

	HongKongArduinoClone_DestroyObjects()
	PostQuitMessage(0)
End Sub

Sub ResetDBM()
	SetWindowText(MWnd(EditBox1),"")
	DBM(ProgramName+" "+VerStr+ex"\r\nProgrammed by RGBA_CRT 2016-2020.\r\nThis program is third-party impremention of HongKongArduino.\r\nOrg Copyright (C) 2014 たにやま\r\n")
End Sub


Dim hFont_LogBox As HFONT
Sub MainWnd_Create(ByRef CreateStruct As CREATESTRUCT)
	ResetDBM()
	
	SetIniPath()

	ListUpComPort(GetDlgItem(hMainWnd, ComList))

	' setup mapper type list box
	Dim i as Long
	for i = 0 To SFC_MAP_TYPE__NUM-1
		SendMessage(MWnd(MAPPING), CB_ADDSTRING, 0, GetMappingString(i) As Long)
	Next i
	
	'SendMessage(MWnd(EditBox1), WM_SETFONT, CreateFont( -12, 0, 0, 0, 400, 0, 0, 0, SHIFTJIS_CHARSET, OUT_RASTER_PRECIS, 0, DEFAULT_QUALITY, FIXED_PITCH, "ＭＳ ゴシック") As DWord , TRUE)
	SendMessage(hMainWnd, WM_SETICON, ICON_SMALL, LoadImage(GetModuleHandle(0), IDI_ICON1 As BytePtr, IMAGE_ICON, GetSystemMetrics(SM_CXSMICON), GetSystemMetrics(SM_CYSMICON), LR_DEFAULTCOLOR) As Long)
	
	SetCheckBox(MWnd(CheckBox6), TRUE)
	
	SetDlgEnable(STATUS_CLOSED)
	
	Dim buf[100] AS Byte
	Dim tmp AS DWord
	For i = 0 To 7
		tmp = &H80 << i
		SendMessage(MWnd(ROM_SIZE), CB_ADDSTRING, 0, sprintfStr("%dKB [%dMbit]", (tmp) As DWord, (tmp * 8 / 1024) As DWord) )
		tmp = &H02 << i
		SendMessage(MWnd(SRAM_SIZE), CB_ADDSTRING, 0, sprintfStr("%dKB [%dKbit]", (tmp) As DWord, (tmp * 8) As DWord) )
	Next i
	
	Dim baudrate As DWord
	baudrate = GetPrivateProfileInt(ProgramName, "BaudRate", DEFAULT_BAUDRATE, INIFILE_PATH)
	If baudrate = 0 Then baudrate = DEFAULT_BAUDRATE
	
#IFDEF _DEBUG
	MoveWindow(hMainWnd, 0, 0, 505, 330, TRUE)
#endif
	
	SetWindowText(MWnd(EditBox6), Str$(baudrate))

	wsprintf(buf, "%s %s", ProgramName, VerStr)
	SetWindowText(hMainWnd, buf)

	hFont_LogBox=CreateFont(-12,0,0,0,400,0,0,0,128,3,2,1,50,"MS Gothic")
	SendMessage(GetDlgItem(hMainWnd,EditBox1),WM_SETFONT,hFont_LogBox As WPARAM,0)
End Sub

Sub SetIniPath()
	'INIファイルへのパスを記録
	Dim Path[MAX_PATH + 20] As Byte, i As Long
	
	'自己のファイルパスを取得
	GetModuleFileName(NULL, Path, MAX_PATH)
	For i = lstrlen(Path) To 0 Step -1
		If Path[i] = &H5C then ExitFor' \ だったら
	Next i
	Path[i + 1] = 0'￥以下を潰す
	
	INIFILE_PATH = calloc(lstrlen(Path) + Len(INIFILE_NAME) + 10)
	lstrcpy(INIFILE_PATH, Path)
	lstrcat(INIFILE_PATH, INIFILE_NAME)
End Sub


Sub ListUpComPort_Callback(userdata AS VoidPtr, PortName As BytePtr, FriendlyName AS BytePtr)
	Dim hCombobox As HWND
	hCombobox = userdata

	Dim textbuf[64] As Byte
	wsprintf(textbuf, ex"%s - %s",PortName,FriendlyName)

	PumpMessage()
	' Get Text Width
	Dim size As SIZE, hdc As HDC, hOldFont As HFONT, hNowFont As HFONT
	hdc = GetDC(hCombobox)
	hOldFont = SelectObject(hdc, hFont_MainWnd)
	GetTextExtentPoint32(hdc, textbuf, lstrlen(textbuf), size)
	ReleaseDC(hCombobox,hdc)

	' Adjust Dropdown list width
	Dim currentWidth AS Long
	currentWidth = 	SendMessage(hCombobox, CB_GETDROPPEDWIDTH, 0, 0)
	if currentWidth < size.cx Then SendMessage(hCombobox, CB_SETDROPPEDWIDTH, size.cx+10, 0)

	' add string
	SendMessage(hCombobox,CB_ADDSTRING,0,textbuf As Long)
Endsub

Sub ListUpComPort(Wnd As HWND)

	' 最後に接続したデバイスを取得
	Dim lastDevice aS BytePtr, lastDeviceIdx AS Long
	lastDevice=calloc(128)
	GetPrivateProfileString(ProgramName,"LastDevice","None",lastDevice,128,INIFILE_PATH)

	' デバイス名付きリストアップを試す(Win2K以降)
	Dim sa AS SetupApiWrapper, failed AS BOOL
	if sa.Load() Then
		if EnumSerialPorts(VarPtr(sa), AddressOf(ListUpComPort_Callback), Wnd) = FALSE Then failed=TRUE
	Else
		failed=TRUE
	Endif

	if failed Then
		DBM("Listup serial port failed.")

		SendMessage(Wnd,CB_ADDSTRING,0,lastDevice As Long)
		SendMessage(Wnd,CB_ADDSTRING,0,"COM1" As Long)
		SendMessage(Wnd,CB_ADDSTRING,0,"COM2" As Long)
		SendMessage(Wnd,CB_ADDSTRING,0,"COM3" As Long)
		SendMessage(Wnd,CB_ADDSTRING,0,"<Error>" As Long)
	End If

	'最後に選択されたポートを選ぶ
	lastDeviceIdx=SendMessage(Wnd,CB_FINDSTRINGEXACT,-1,lastDevice As DWord)
	If lastDeviceIdx=CB_ERR Then lastDeviceIdx=0

	'セットする
	SendMessage(Wnd,CB_SETCURSEL,lastDeviceIdx,0)
	 
	free(lastDevice)	
End Sub

Sub ListUpComPort_Old(Wnd As HWND)
	Dim buf As BytePtr,p As DWord,C As Long
	dim QDD_BUFSIZE As DWord

	QDD_BUFSIZE=GetPrivateProfileInt(ProgramName,"QDDSize",DEFAULT_QDD_BUFSIZE,INIFILE_PATH)
	If QDD_BUFSIZE<1024 Then 
		QDD_BUFSIZE=DEFAULT_QDD_BUFSIZE
		DBM("QDD size fixed.")
		WritePrivateProfileString(ProgramName,"QDDSize",Str$(QDD_BUFSIZE),INIFILE_PATH)
	End If

	SendMessage(Wnd,CB_RESETCONTENT,0,0)

	buf=calloc(QDD_BUFSIZE)
	If QueryDosDevice(NULL,buf,QDD_BUFSIZE) = 0 Then 
		SendMessage(Wnd,CB_ADDSTRING,0,"Error!" As Long)
		p=GetLastError()
		DBM(ex"COM Port Listup Error!\r\nCode."+Str$(p))
		If p=122 Then
			ErrMes(hMainWnd,ex"デバイスリストバッファのサイズが小さすぎます\n"+INIFILE_NAME+"を開き、QDDSizeの右辺の値を増やしてください。","QueryDosDevice Error",0)
		End If
		Goto *LUCP_EXIT
	End If	
	Do
		If win_strncmp(buf+p,"COM",3)=TRUE Then
			SendMessage(Wnd,CB_ADDSTRING,0,(buf+p) As Long)
			C++
		End If
		While buf[p]<>0
			p++
		WEnd
		p++
		If buf[p+1]=0 Then Exitdo	'ダブルNULLで終了
	Loop

*LUCP_EXIT
	free(buf)

	If C=0 then SendMessage(Wnd,CB_ADDSTRING,0,"None" As Long)


End Sub

Sub DBM(Text As BytePtr)
	Dim LastPos As DWord, hEB As HANDLE
	hEB = MWnd(EditBox1)
	LastPos = GetWindowTextLength(hEB)
	
	'10KBを超えてたらログをクリア
	If LastPos>1024 * 10 Then
		'1KB残す
		Dim txt AS BytePtr
		txt = calloc(LastPos + 1)
		GetWindowText(hEB, txt, LastPos)
		SetWindowText(hEB, txt + LastPos -1024)
		free(txt)
		LastPos = 1025
	End If
	
	SendMessage(hEB, EM_SETSEL, LastPos, LastPos)
	SendMessage(hEB, EM_REPLACESEL, 0, Text As Long)
	SendMessage(hEB, EM_REPLACESEL, 0, ex"\r\n" As Long)
	OutputDebugString(Text)
	OutputDebugString(ex"\r\n")
End Sub

Sub DBMN(Text As BytePtr)
	Dim LastPos As DWord, hEB As HANDLE
	hEB = MWnd(EditBox1)
	LastPos = GetWindowTextLength(hEB)
	SendMessage(hEB, EM_SETSEL, LastPos, LastPos)
	SendMessage(hEB, EM_REPLACESEL, 0, Text As Long)
End Sub

'printfのDBM版
Sub DBMf(lpFormat As BytePtr)(a As DWord ,b As DWord ,c As DWord ,d As DWord ,e As DWord ,f As DWord ,g As DWord ,h As DWord ,i As DWord ,j As DWord ,k As DWord ,l As DWord ,m As DWord ,n As DWord ) 
	Dim dbuf[1024] As Byte
	Dim p AS DWord
	p=wsprintf(dbuf,lpFormat,a,b,c,d,e,f,g,h,i,j,k,l,m,n)

	DBM(dbuf)
EndSub

Sub BaudrateErrorMessage()
	' 初回
	if isFirstBaudrateError = FALSE Then
		Dim text_jpn=ex"通信に失敗しました。使用しているArduinoに合わせてボーレートを調整してください。(詳細はReadme参照)\n\n最大ボーレートは使用しているシリアルコンバータに依存します。例:\n  [公式Arduino UNO] ATmega8U2: 500,000 bps\n  [Arduino互換機] CH340: 1,000,000 bps" As BytePtr
		Dim text_eng=ex"Communication failed. Please adjust baudrate for your Arduino (see README.md)" As BytePtr
		MessageBox(hMainWnd, text_jpn, text_eng, MB_OK OR MB_ICONERROR)
		DBM(text_eng)
		DBM(ex"Example:\r\n- Offical Arduino: 500000bps\r\n- Compatible(CH340): 1000000bps")
		isFirstBaudrateError=TRUE
	End If
End Sub

Sub MainWnd_CommandButton5_Click()
	'設定保存
	SaveIniFile()
	
	If hCOM = 0 then
		'接続
		Dim txCom As BytePtr, rate As DWord, i As Long
		
		rate = GetDlgItemInt(hMainWnd, EditBox6, NULL, FALSE)
		If rate = 0 Then
			ErrMes(hMainWnd, "ボーレートが不正です。", "Invalid baud rate", 0)
			ExitSub
		End If
		
		txCom = GetWndTextMalloc(GetDlgItem(hMainWnd, ComList))
		DBMN("Connect to "): DBM(txCom)
		for i=0 To 10
			if txCom[i] = 0 Then ExitFor
			if txCom[i] = &H20 Then
				txCom[i] = 0
				ExitFor
			End If
		Next i
		
		'bufferlen
		Dim bufferSize AS DWord
		bufferSize = GetPrivateProfileInt(ProgramName, "DumpBufferSize", DEFAULT_DUMP_SIZE, INIFILE_PATH)
		If bufferSize <= 0 Then bufferSize = DEFAULT_DUMP_SIZE
		
		'connect and reset ボーレート
		hCOM = OpenComPort(txCom, INITIAL_BAUDRATE, bufferSize, 1024 * 10)
		ResetArduino(hCOM)
		CloseHandle(hCOM)
		
		'reconnect, 接続を確立
		hCOM = OpenComPort(txCom, INITIAL_BAUDRATE, bufferSize, 1024 * 10)
		
		
		If hCOM = NULL Then
			ErrMes(hMainWnd, MakeStr(txCom) + ex"への接続に失敗しました。", "Connection failed", 0, GetLastError())
			DBM("Serial connection Failed.")
			hCOM = 0
			free(txCom)
			ExitSub
		Else
			DBM(ex"Connection Stage1 OK.\r\n")
		End If
		free(txCom)
		
		SetWindowText(MWnd(CommandButton5), "&Close")
		SetDlgEnable(STATUS_CONNECTED)
		
		'正常なデータ通信を確立(できるようになるまでリトライ）
		If CheckFirmware(hCOM, TRUE) = FALSE Then
			'	ErrMes(hMainWnd,"指定されたデバイスはHongKoongArduinoではありません。",0,0)
			goto * HKAF_CON_ERR
		End If
		DBM(ex"Connection Stage2 OK.\r\n")
		
		'ボーレート変更コマンド送信
		if rate <> INITIAL_BAUDRATE Then
			ChangeBaudrate(hCOM, rate)
			DBM("baudrate=" + Str$(rate) + "bps")
			
			'変更後の正常なデータ通信を確立
			DBM("changeing baudrate...")
			If CheckFirmware(hCOM, FALSE) = FALSE Then
				DBM("invailde baudrate")
				BaudrateErrorMessage()
				goto * HKAF_CON_ERR
			End If
		End If
		
		DBM(ex"Connection Successful!!!\r\n")
		
		'GetCartInfo
		MainWnd_CommandButton1_Click()
		
	Else
		'切断
		DisconnectDevice()		
	End If
	
	ExitSub
*HKAF_CON_ERR
	DisconnectDevice()
	SetWindowText(MWnd(SRAM_SIZE), "")
	SetWindowText(MWnd(ROM_SIZE), "")
	SetWindowText(MWnd(ROMTITLE), "")
	SetWindowText(MWnd(CART_CIPS), "")
	SetWindowText(MWnd(MAPPING), "")
End Sub

Sub DisconnectDevice()
	If hCOM = 0 Then ExitSub
	CloseHandle(hCOM)
	hCOM = 0
	SetWindowText(MWnd(CommandButton5), "&Connect")
	SetDlgEnable(STATUS_CLOSED)
	
	DBM(ex"Connection is closed.\r\n")
End Sub

Sub SetDlgEnable(Mode As DLG_STATUS)
	'ボタンの有効/無効セット
	
	Dim isEnable As Long
	If Mode = STATUS_CONNECTED Or Mode = STATUS_DUMPING then
		isEnable = FALSE
	Else Mode = STATUS_CLOSED Then
		isEnable = TRUE
	End If
	EnableWindow(MWnd(ComList), isEnable)
	EnableWindow(MWnd(EditBox6), isEnable)
	EnableWindow(MWnd(Static9), isEnable)
	EnableWindow(MWnd(Static10), isEnable)
	
	If Mode = STATUS_DUMPING Then isEnable = NOT(isEnable) And &H01
	
	EnableWindow(MWnd(CommandButton1), NOT(isEnable) And &H01)
	EnableWindow(MWnd(CommandButton2), NOT(isEnable) And &H01)
	EnableWindow(MWnd(CommandButton3), NOT(isEnable) And &H01)
	EnableWindow(MWnd(CommandButton4), NOT(isEnable) And &H01)
	EnableWindow(MWnd(CommandButton17), NOT(isEnable) And &H01)
	
	EnableWindow(MWnd(MAPPING), NOT(isEnable) And &H01)
	EnableWindow(MWnd(ROM_SIZE), NOT(isEnable) And &H01)
	EnableWindow(MWnd(SRAM_SIZE), NOT(isEnable) And &H01)
	EnableWindow(MWnd(CB_MANUAL), NOT(isEnable) And &H01)
	
	If Mode = STATUS_DUMPING Then
		EnableWindow(MWnd(CommandButton5), FALSE)
	Else
		EnableWindow(MWnd(CommandButton5), TRUE)
	End If
	
	DlgStatus = Mode
End Sub

Function GetWndTextMalloc(hWnd As HWND) As BytePtr
	'コントロールのテキスト取得
	Dim buf As BytePtr
	buf = calloc(GetWindowTextLength(hWnd) + 20)
	GetWindowText(hWnd, buf, GetWindowTextLength(hWnd) + 1)
	
	GetWndTextMalloc = buf
End Function

Sub MainWnd_KeyUp(KeyCode As Long, flags As Long)
'	DBM("PressKey:"+Hex$(KeyCode))
	Select Case KeyCode
		Case &H70 : SpeedTest()	'F1
		Case &H71 : CheckFirmware(hCOM,FALSE)	'F2
		Case &H74 : ListUpComPort(GetDlgItem(hMainWnd,ComList))
		Case &H78 : MainWnd_CommandButton12_Click()
		Case &H7A : MainWnd_CommandButton15_Click()
		Case &H7B : MainWnd_CommandButton13_Click()

		'(このメッセージはフォーカスが無い状態なので)TABキーが押されたら適当なボタンにフォーカスを当てる
		'Case VK_TAB : SetFocus( GetNextDlgTabItem(hMainWnd, 0, TRUE))
	End Select
End Sub

Sub SpeedTest()
	'Arduinoとの接続速度テスト
	Dim rd As BytePtr, mes[256] As Byte, total As DWord, lt As DWord, i As Long
	Const TEST_READ_SIZE = 1024 * 10
	DBM("Speedtest : Read " + Str$(TEST_READ_SIZE / 1024) + "KB*10")
	rd = calloc(TEST_READ_SIZE)
	total = 0
	lt = 0
	For i = 0 To 9
		lt = GetTickCount()
		ReadROM(hCOM, rd, 0, i * TEST_READ_SIZE, TEST_READ_SIZE, FALSE)
		total + = GetTickCount() - lt
		wsprintf(mes, ex"\t[%d]Time : %dms", i, GetTickCount() - lt)
		DBM(mes)
	Next i
	wsprintf(mes, ex"Total:%dms\r\nAverage:%dms\r\nSpeed : %dbyte/sec (%dKB/s)\r\n", total, total / 9, (TEST_READ_SIZE * 10) / (total / 1000), (TEST_READ_SIZE * 10) / (total / 1000) / 1000)
	DBM(mes)
	free(rd)
End Sub



Sub MainWnd_CommandButton2_Click()
	'ROM吸出しボタン

	Dim info As SFC_CART_INFO
	Dim path As BytePtr

	If GetDumpConfig(VarPtr(info)) <> TRUE Then 
		DBM("GetDumpConfig() Error")
		ExitSub
	End If
'	info.RomSize = &H400000	'debug

#ifndef _DEBUG
	path=SaveDialogCalloc(ex"SFC ROMイメージファイル(*.sfc)\0*.sfc\0すべてのファイル(*.*)\0*.*\0\0", "sfc", info.Title)
	If path=0 Then ExitSub
#else
	path="dump.sfc"
#endif

	Dim ret AS Long
	ret = DumpFullROM(VarPtr(info), path)

	if ret = HKAC_DUMPROM_OK Then
		MessageBeep(MB_ICONASTERISK)

	Else
		if ret = HKAC_DUMPROM_RETRY_OVER Then
			BaudrateErrorMessage()
		End If

	End If

#ifndef _DEBUG
	free(path)
#endif

End Sub

Sub MainWnd_QueryClose(ByRef cancel As Integer)
	SaveIniFile()
End Sub

Sub SaveIniFile()
	Dim ratestr As BytePtr, Tmp As DWord
	
	ratestr = GetWndTextMalloc(MWnd(EditBox6))
	WritePrivateProfileString(ProgramName, "BaudRate", ratestr, INIFILE_PATH)
	free(ratestr)
	
	ratestr = GetWndTextMalloc(MWnd(ComList))
	WritePrivateProfileString(ProgramName, "LastDevice", ratestr, INIFILE_PATH)
	free(ratestr)
	
	Tmp = GetPrivateProfileInt(ProgramName, "DumpErrorRetryLimit", DEFAULT_CONTINUE, INIFILE_PATH)
	WritePrivateProfileString(ProgramName, "DumpErrorRetryLimit", Str$(Tmp), INIFILE_PATH)
	
	Tmp = GetPrivateProfileInt(ProgramName, "QDDSize", DEFAULT_QDD_BUFSIZE, INIFILE_PATH)
	If Tmp = 0 Then Tmp = DEFAULT_QDD_BUFSIZE
	WritePrivateProfileString(ProgramName, "QDDSize", Str$(Tmp), INIFILE_PATH)
	
	Tmp = GetPrivateProfileInt(ProgramName, "DumpBufferSize", DEFAULT_DUMP_SIZE, INIFILE_PATH)
	If Tmp <= 0 Then Tmp = DEFAULT_DUMP_SIZE
	WritePrivateProfileString(ProgramName, "DumpBufferSize", Str$(Tmp), INIFILE_PATH)
	
	WritePrivateProfileString(ProgramName, "RxTimeoutMargine", Str$(HKAC_RX_TIMEOUT_MARGIN), INIFILE_PATH)
End Sub

Sub MainWnd_CommandButton3_Click()
	Dim fout As File
	Dim info As SFC_CART_INFO
	Dim path As BytePtr

	If GetDumpConfig(VarPtr(info)) <> TRUE Then 
		DBM("GetDumpConfig() Error")
		ExitSub
	End If

#ifndef _DEBUG
	path=SaveDialogCalloc(ex"SRAMイメージファイル(*.srm)\0*.srm\0すべてのファイル(*.*)\0*.*\0\0","srm",info.Title)
	If path=0 Then ExitSub
#else
	path="dump.srm"
#endif

	If fout.openFile(path, GENERIC_WRITE) = FALSE Then
		DBMf("Cannot open file: %s",path As DWord)
		Goto *D_EXIT
		ExitSub
	End If

	Dim sram As BytePtr
	sram = calloc(info.SramSize)

	Dim mmap As SFC_MMAP_MODEL
	GetMmapModel(VarPtr(info), FALSE, VarPtr(mmap))

	DBM("Dumping SRAM...")
	DBMf("SramSize = %d KB", info.SramSize>>10)
	DBMf("bankSize = %d KB", mmap.sram.bankSize>>10)
	DBMf("bankCount= %d", Int(info.SramSize / mmap.sram.bankSize))
	
	Dim pc AS *SramProgressCallBack 
	pc = new_SramProgressCallBack()

	DumpSRAM(hCOM, VarPtr(info), VarPtr(mmap), sram,  pc As *ProgressCallBack)

	delete_SramProgressCallBack(pc)
	DBM(ex"SRAM dumping successful!!!\r\n")

	fout.write(sram, info.SramSize)

*D_EXIT
	fout.close()
	if sram Then free(sram)
#ifndef _DEBUG
	free(path)
#endif

	MessageBeep(MB_ICONASTERISK)

End Sub

Sub MainWnd_CommandButton4_Click()
	Dim fin As File
	Dim path As BytePtr
	
	Dim info As SFC_CART_INFO
	If GetDumpConfig(VarPtr(info)) <> TRUE Then 
		DBM("GetDumpConfig() Error")
		ExitSub
	End If
	
	If info.isFlashSave Then
		ErrMes(hMainWnd, "フラッシュメモリ方式のセーブデータ書き込みは現在未実装です。", "未実装", 0)
		If GetKeyState(VK_ESCAPE) And &H80 = 0 Then exitsub
	End If
	
#ifndef _DEBUG
	path = LoadDialogCalloc(ex"SRAMイメージファイル(*.srm)\0*.srm\0すべてのファイル(*.*)\0*.*\0\0", "srm")
	If path = 0 Then ExitSub
#else
	If GetKeyState(VK_ESCAPE) And &H80 Then
		path = LoadDialogCalloc(ex"SRAMイメージファイル(*.srm)\0*.srm\0すべてのファイル(*.*)\0*.*\0\0", "srm")
	Else
		path = "write.srm"
	End If
#endif

	If MessageBox(hMainWnd, ex"セーブデータが上書きされます。\nまた、正常に書き込める保障はありません。\n続行しますか？", ProgramName+" - SRAM write", MB_YESNO or MB_ICONWARNING) = IDNO Then ExitSub

	'READ FILE
	Dim writeBuffer As BytePtr
	If fin.openFile(path, GENERIC_READ) = FALSE Then
		DBMf("Cannot open file: %s", path As DWord)
		ErrMes(hMainWnd, "SRAMファイルが開けませんでした。", "File Open Error", 0, GetLastError())
		Goto *WS_EXIT
	End If

	writeBuffer = calloc(info.SramSize)
	fin.read(writeBuffer, info.SramSize)
	fin.close()
	
	Dim mmap As SFC_MMAP_MODEL
	GetMmapModel(VarPtr(info), FALSE, VarPtr(mmap))
	
	DBMf("SramSize = %d KB", info.SramSize>>10)
	DBMf("bankSize = %d KB", mmap.sram.bankSize>>10)
	DBMf("bankCount= %d", Int(info.SramSize / mmap.sram.bankSize))

	DBM("Writing SRAM...")
	WriteSRAM(hCOM, VarPtr(info), VarPtr(mmap), writeBuffer, NULL)

	'verify
	DBMN("Verifying...")
	Dim verifyBuffer As BytePtr, diffPos AS DWord
	verifyBuffer = calloc(info.SramSize)
	DumpSRAM(hCOM, VarPtr(info),  VarPtr(mmap), verifyBuffer, NULL)
	if compareBinaly(verifyBuffer, writeBuffer, info.SramSize, VarPtr(diffPos)) Then
		DBM("OK")
		DBM(ex"SRAM writing successful!!!\r\n")
		MessageBeep(MB_ICONASTERISK)
	Else
		DBMf(ex"NG at 0x%08X", diffPos)
		DBM(ex"Failed to write SRAM.\r\n")
		printf("=== write ===\n")
		Dump(writeBuffer+(diffPos And &HFFFFFFF0), 32)
		printf("=== actual ===\n")
		Dump(verifyBuffer+(diffPos And &HFFFFFFF0), 32)
		MessageBeep(MB_ICONHAND)
	End If
	
*WS_EXIT
#ifndef _DEBUG
	free(path)
#endif
	if writeBuffer Then free(writeBuffer): writeBuffer=NULL
	if verifyBuffer Then free(verifyBuffer): verifyBuffer=NULL

End Sub

Function compareBinaly(dat1 AS BytePtr, dat2 AS BytePtr,length aS DWord)( pos As *DWord) AS BOOL
	Dim i  AS DWord
	For i = 0 To length-1
		if dat1[i]<>dat2[i] Then
			compareBinaly=FALSE
			if pos Then SetDWord(pos, i)
			ExitFunction
		EndIf
	Next i
	compareBinaly=TRUE
End Function

Function SaveDialogCalloc(filter As BytePtr, ext As String)(defFileName As BytePtr) As BytePtr
	Dim tOfn As OPENFILENAME, i As DWord
	
	'ファイルオープン構造体の初期化
	tOfn.lStructSize = SizeOf(OPENFILENAME) - SizeOf(DWord) * 2 - SizeOf(VoidPtr)
	tOfn.hwndOwner = hMainWnd
	tOfn.lpstrFilter = filter'ex"wavファイル(*.wav)\0*.wav\0すべてのファイル(*.*)\0*.*\0\0"'StrPtr(sFilter)
	tOfn.nFilterIndex = 1
	tOfn.nMaxFile = MAX_PATH
	tOfn.Flags = OFN_OVERWRITEPROMPT
	tOfn.lpstrDefExt = StrPtr(ext)'"wav"
	tOfn.lpstrFile = calloc(MAX_PATH + 10)
	If defFileName<>0 Then lstrcpy(tOfn.lpstrFile, defFileName)
	
	'ファイルオープンダイアログを表示する
	If GetSaveFileName(tOfn) = 0 Then
		ExitFunction
	End If
	
	SaveDialogCalloc = calloc(lstrlen(tOfn.lpstrFile) + 1)
	lstrcpy(SaveDialogCalloc, tOfn.lpstrFile)
	free(tOfn.lpstrFile)
End Function

Function LoadDialogCalloc(filter As BytePtr, ext As String) As BytePtr
	Dim tOfn As OPENFILENAME, i As DWord
	
	'ファイルオープン構造体の初期化
	tOfn.lStructSize = SizeOf(OPENFILENAME) - SizeOf(DWord) * 2 - SizeOf(VoidPtr)
	tOfn.hwndOwner = hMainWnd
	tOfn.lpstrFilter = filter'ex"wavファイル(*.wav)\0*.wav\0すべてのファイル(*.*)\0*.*\0\0"'StrPtr(sFilter)
	tOfn.nFilterIndex = 1
	tOfn.nMaxFile = MAX_PATH
	tOfn.Flags = OFN_OVERWRITEPROMPT
	tOfn.lpstrDefExt = StrPtr(ext)'"wav"
	tOfn.lpstrFile = calloc(MAX_PATH + 10)
	
	'ファイルオープンダイアログを表示する
	If GetOpenFileName(tOfn) = 0 Then
		ExitFunction
	End If
	
	LoadDialogCalloc = calloc(lstrlen(tOfn.lpstrFile) + 1)
	lstrcpy(LoadDialogCalloc, tOfn.lpstrFile)
	free(tOfn.lpstrFile)
End Function

Sub MainWnd_RButtonDblClick(flags As Long, x As Integer, y As Integer)
	ResetDBM()
	DBM("Cleared Log.")
End Sub

Sub MainWnd_Static1_DblClick()
	exec("http://susumutaniyama.github.io/HongKongArduino/")
End Sub

'リードテスト
Sub MainWnd_CommandButton6_Click()
	Dim f As File
	If hCOM = 0 Then ExitSub
	Dim data As BytePtr, adr As DWord
	data = calloc(&H10000)
	adr = GetDlgItemHex(MWnd(EditBox2))
	DBM("Dump 0x" + Hex$(adr))
	
	ReadROM(hCOM, data, 0, adr, &h5000, NOT(GetCheckBox(MWnd(CheckBox6))) And &H01)
	f.openFile("test.bin", GENERIC_WRITE)
	f.write(data, &h5000)
	f.close()
	DBM("OK")
	Dim p As BytePtr, i As Long
	p = data + &H5000
	For i = 0 To 7
		p + = wsprintf(p, "%02X ", data[i])
	Next i
	p + = wsprintf(p, ex"\r\n", data[i])
	For i = 0 To 7
		p + = wsprintf(p, "[%c]", data[i])
	Next i
	DBM(data + &H5000)
	Dump(data, 128)
End Sub

Sub MainWnd_MButtonDblClick(flags As Long, x As Integer, y As Integer)
	'ESC+マウス中ボタンダブルクリックでテストモード
	If GetCancelKey() Then 
		MoveWindow(hMainWnd,0,0,505,330,TRUE)
		AllocConsole()
		_System_hConsoleOut=GetStdHandle(STD_OUTPUT_HANDLE)
		printf(ex"Welcome to debug console\n")
	End If

End Sub



Sub MainWnd_CommandButton8_Click()
	If hCOM=0 Then ExitSub
	Dim ctrl As Byte
	ctrl=(GetCheckBox(MWnd(CheckBox2))<<3 or GetCheckBox(MWnd(CheckBox3))<<2 or _
		GetCheckBox(MWnd(CheckBox4))<<1 or GetCheckBox(MWnd(CheckBox5))) As Byte
	DBM("SetCtrlBus : 0"+Hex$(ctrl))

	SendControl(hCOM,ctrl)
End Sub

Sub MainWnd_CommandButton9_Click()
	DBM("回路デバッグモード")
	DBM("ESCキーで抜ける")
	Do
		MainWnd_CommandButton1_Click()
		Sleep(300)
		PumpMessage()
		If GetKeyState(VK_ESCAPE) And &H80 Then ExitDo
	Loop
End Sub

Sub MainWnd_CommandButton1_Click()
	SetRomInfoToDlg_FromROM()
End Sub

Sub SetRomInfoToDlg_FromROM()
	Dim buf[SFC_SPEC_HEADER_SIZE+2] As Byte,cartInfo As SFC_CART_INFO
	'DBM( "Cartridge Infomation")

	'ヘッダを読み出し
	FlushCom(hCOM)
	getCartInfo(VarPtr(cartInfo))
	printf(ex"=== ROM HEADER ===\n")
	Dump(VarPtr(cartInfo.rawHeader), sizeof(SFC_CART_HEADER))

	'ダイアログに表示
	SetCartInfo(VarPtr(cartInfo))

	Dim info_text[1024] as Byte
	GenerateHeaderInfoText(VarPtr(cartInfo), info_text, 1024)
	DBMN(info_text)
	
	'Manualのチェックを外す
	SetCheckBox(MWnd(CB_MANUAL),FALSE)

	'BSスロットがあればBSMWndを出す
	If cartInfo.isBSX Then
		BSM_open()

		Dim idx AS Long
		If cartInfo.Chipset=&HE5 Then
			idx=BSM_SLOT_BIOS
		Elseif cartInfo.MapType=SFC_MAP_LoROM or cartInfo.MapType=SFC_MAP_SpLoROM then
			idx=BSM_SLOT_SpLoROM
		Elseif cartInfo.MapType=SFC_MAP_HiROM then
			idx=BSM_SLOT_HiROM
		Elseif cartInfo.MapType=SFC_MAP_SA1 then
			idx=BSM_SLOT_SA1
		Else
			DBM("[!!!]Warning: unknown BS-X slot")
		End If
	'	debug
		SendMessage(BSMWnd(BSM_CT),CB_SETCURSEL,idx,0)
		PumpMessage()
	Else
		BSM_close()
	End If
	
	If cartInfo.MapType=SFC_MAP_SF_MENU Then
		SFM_open()
	End If	

	SetCheckBox(MWnd(CheckBox7),hasClockModule(hCOM))

	'アクセスランプをLow
	SetAddress(hCOM,&H000000,FALSE)
End Sub



Sub MainWnd_CommandButton10_Click()
	SPC7110_PrintBanks(hCOM)
	SPC7110_SetBanks(hCOM,0,TRUE)
	SPC7110_PrintBanks(hCOM)
	SPC7110_SetBanks(hCOM,0,FALSE)
	SPC7110_PrintBanks(hCOM)
End Sub


'---------------------------------------------------------------------------------------------------


'吸出し設定をROMとGUIから読み出し
Function GetDumpConfig(info As *SFC_CART_INFO) As BOOL
	if getCartInfo(info) <> TRUE Then ExitFunction

	GetDlgOption(info)	'infoにGUIの設定を反映

	SetCartInfo(info)
	GetDumpConfig=TRUE
End Function


Function getCartInfo(info As *SFC_CART_INFO) As BOOL
	'カートリッジからヘッダをロード
	Dim buf[SFC_SPEC_HEADER_SIZE+5] As Byte
	/*ReadROM(hCOM,buf, 0, SFC_SPEC_HEADER_ADDR, SFC_SPEC_HEADER_SIZE,FALSE)
	SloveCartInfo(buf As *SFC_CART_HEADER,VarPtr(info))*/
	
'	SetCPU_Clock(hCOM,HKAC_CLOCK_NORMAL)	'clock
	SendControl(hCOM,CBUS_DEFAULT)	'default

	If ReadROM(hCOM,buf, 0, SFC_SPEC_HEADER_ADDR, SFC_SPEC_HEADER_SIZE,FALSE)<SFC_SPEC_HEADER_SIZE Then
		lstrcpy(info->Title,"[ERR]通信エラー")
		SetCartInfo(info)
		ErrMes(hMainWnd,ex"通信エラーが発生しました。\nArduinoをリセットしてください。","Device was lost",0)
		DisconnectDevice()
		ExitSub
	End If
	SloveCartInfo(buf As *SFC_CART_HEADER,info)

	getCartInfo = TRUE
End Function

Function getSelectedMapMode() AS Long
	Dim idx AS Long
	idx=SendMessage(MWnd(MAPPING),CB_GETCURSEL,0,0) Mod SFC_MAP_TYPE__NUM
	if idx<0 or idx>=SFC_MAP_TYPE__NUM Then
		DBM("!!!!ASSERT, idx is over.")
		idx=0
	End If
	getSelectedMapMode=idx

End Function
Sub GetDlgOption(info As *SFC_CART_INFO)
	'LoROM/HiROMの選択とMAD1のチェック取得
	If GetCheckBox(MWnd(CB_MANUAL)) Then
		info->MapType = getSelectedMapMode()
		'		info->MapMode = (info->MapMode And &HF0) or info->MapType
		info->RomSize = HKAC_GetWindowInt(MWnd(ROM_SIZE))
		info->SramSize = HKAC_GetWindowInt(MWnd(SRAM_SIZE))
		printf(ex"custom rom size = %d\n", (info->RomSize / 1024 / 1024) AS DWord)
	End If
 End Sub

'MapMode (20 SrowRom LoROMのやつ）のGUI用関数
Function MapModeToComboboxIndex(mapMode As SFC_MAP_TYPE) As Long
	MapModeToComboboxIndex = mapMode As Long
End Function



'カートリッジ情報をGUIに反映
Sub SetCartInfo(info As *SFC_CART_INFO)
	'このルーチンからはManualのチェックが変わらないようにする
	Dim bManual AS BOOL
	bManual=GetCheckBox(MWnd(CB_MANUAL))

	SetWindowText(MWnd(ROMTITLE),info->Title)
	SendMessage(MWnd(MAPPING),CB_SETCURSEL,MapModeToComboboxIndex(info->MapType),0)
	MainWnd_MAPPING_SelChange()

	SetWindowText(MWnd(CART_CIPS), GetChipsetString(info))
	
	If info->RomSize =0 Then
		SetWindowText(MWnd(ROM_SIZE),"None")		
	Else
		SetWindowText(MWnd(ROM_SIZE),sprintfStr("%dKB [%dMbit]",
							(info->RomSize/1024) As DWord, (info->RomSize*8/(1024^2)) As DWord))
	End If
	If info->SramSize =0 Then
		SetWindowText(MWnd(SRAM_SIZE),"None")		
	Else
		Dim FLASH_TEXT AS BytePtr
		If info->isFlashSave Then
			FLASH_TEXT="[FLASH]"
		Else
			FLASH_TEXT=""
		End If
		SetWindowText(MWnd(SRAM_SIZE),sprintfStr("%dKB [%dKbit]%s",
			(info->SramSize/1024) As DWord, (info->SramSize*8/1024) As DWord, FLASH_TEXT As DWord))
	End If

	SetCheckBox(MWnd(CB_MANUAL),bManual)

End Sub	

Function GetCheckBox(Ctrl As HWND) As Byte
	If SendMessage(Ctrl,BM_GETCHECK,0,0) = BST_CHECKED then
		GetCheckBox=TRUE
	Else
		GetCheckBox=FALSE
	End If
End Function

Function SetCheckBox(Ctrl As HWND,bValue As BOOL) As Byte
	SendMessage(Ctrl,BM_SETCHECK,bValue,bValue)
End Function


Sub MainWnd_CheckBox6_Click()

End Sub

Sub RomCommand(Adr As DWord,val As DWord)
	Dim loAdr As DWord,tmp As DWord
	loAdr=&H8000 or (Adr And &H7FFF) or (Adr And &HFF8000)<<1
	DBM("CMD:"+Hex$(loAdr)+":"+Hex$(val))
	WriteROM(hCOM,VarPtr(val),0,Adr,1,TRUE)
End Sub

Sub MainWnd_CommandButton11_Click()
/*	Dim buf[20+512] As Byte
	RomCommand(BSX_MEMPACK_ADR_LoROM,&H38)
	RomCommand(BSX_MEMPACK_ADR_LoROM,&HD0)
	RomCommand(BSX_MEMPACK_ADR_LoROM,&H71)
	ReadROM(hCOM,buf,0,BSX_MEMPACK_ADR_LoROM,1,TRUE)
	DBM(Hex$(buf[0]))
	Sleep(50)
	ReadROM(hCOM,buf,0,BSX_MEMPACK_ADR_LoROM,1,TRUE)
	DBM(Hex$(buf[0]))
	RomCommand(BSX_MEMPACK_ADR_LoROM,&H72)
	RomCommand(BSX_MEMPACK_ADR_LoROM,&H75)
	ReadROM(hCOM,buf,0,BSX_MEMPACK_ADR_LoROM+&HFF00,20,TRUE)
	Dim p As BytePtr,i As Long
	p=buf+30
	For i=0 To 20
		p+=wsprintf(p,"%02X ",buf[i])
	Next i
	p+=wsprintf(p,ex"\r\n",buf[i])
	For i=0 To 20
		p+=wsprintf(p,"[%c]",buf[i])
	Next i
	p+=wsprintf(p,ex"\r\n",buf[i])
	p+=wsprintf(p,ex"\r\n",buf[i])
	DBM(buf+30)

	DBM(buf)
*/
	BSM_open()

End Sub

/*
Function Lo2Hi(Adr As DWord) As DWord
	Lo2Hi = (Adr And &HFF8000)<<1 or (Adr And &H007FFF) or &H8000
	
End Function
*/

Sub MainWnd_DropFiles(hDrop As HDROP)
	Dim buf[MAX_PATH] As Byte
	Dim i as long
	
	DBM("ROM File Infomation : ")
	Do
		If DragQueryFile(hDrop, i, buf, MAX_PATH) = 0 Then Exit Do
		i++
	Loop
	DragFinish(hDrop)
	
	Dim file AS File, header As SFC_CART_HEADER, cartInfo AS SFC_CART_INFO
	If file.openFile(buf, GENERIC_READ) = FALSE Then ExitSub
	
	'ヘッダ位置候補 HiROM,LoROM,HiROM(ヘッダ付き),LoROM(ヘッダ付き)
	Dim headerAdrs[4] = [&HFFB0, &H7FB0, &HFFB0 + &H200, &H7FB0 + &H200] AS DWord
	For i = 0 To 3
		file.setFilePtr(headerAdrs[i])
		file.read(VarPtr(header), SFC_SPEC_HEADER_SIZE)
		
		If isSnesHeader(VarPtr(header)) = TRUE Then ExitFor
	Next i
	
	file.close()
	
	If isSnesHeader(VarPtr(header)) = FALSE Then
		DBM(ex"ROM Header not found!\r\n")
		MessageBeep(MB_ICONEXCLAMATION)
		ExitSub
	Else
		DBM("Found header at 0x" + Hex$(headerAdrs[i]))
	End If
	
	SloveCartInfo(VarPtr(header), VarPtr(cartInfo))
	SetCartInfo(VarPtr(cartInfo))

	Dim infotext[HEADER_INFO_TEXT_LEN] As Byte
	GenerateHeaderInfoText(VarPtr(cartInfo), infotext, HEADER_INFO_TEXT_LEN)
	DBM(infotext)
End Sub


'これやるとOSとデバイス間の通信も切れる

Sub ResetArduino(hCOM AS HANDLE)
	EscapeCommFunction(hCOM, SETDTR)
	Sleep(50)
	EscapeCommFunction(hCOM, CLRDTR)
	Sleep(50)
End Sub


Sub MainWnd_CommandButton12_Click()
	DBM("CPU CLOCK OVERCLOCKED")
	SetCPU_Clock(hCOM, HKAC_CLOCK_CPU_OVERCLOCKED)
	
End Sub

Sub MainWnd_CommandButton15_Click()
	MainWnd_CommandButton17_Click()
End Sub

Sub MainWnd_CommandButton13_Click()
	DBM("CPU CLOCK DISABLE")
	SetCPU_Clock(hCOM, HKAC_CLOCK_DISABLED)
End Sub

Sub MainWnd_CommandButton14_Click()
	SFM_open()
End Sub

Dim MW_bMove AS BOOL

Sub MainWnd_Move(x As Integer, y As Integer)
	If MW_bMove = TRUE Then ExitSub
	
	If hSFMem<>NULL then
		MoveChildWindow(hMainWnd, hSFMem)
	End If
	If hBSMem<>NULL Then
		MoveChildWindow(hMainWnd, hBSMem)
	End If
End Sub

Sub MoveChildWindow(owner AS HWND, child AS HWND)
	Dim rect aS RECT
	GetWindowRect(owner, rect)
	rect.right = rect.right + GetSystemMetrics(SM_CXSIZEFRAME) * 2'10
	'面白い挙動するので残しておく
	'SetWindowPos(hSFMem,NULL,rect.top,rect.right,0,0,SWP_NOSIZE or SWP_SHOWWINDOW)
	
	MW_bMove = TRUE
	SetWindowPos(child, NULL, rect.right, rect.top, 0, 0, SWP_NOSIZE or SWP_NOZORDER or SWP_NOOWNERZORDER or SWP_NOACTIVATE)
	MW_bMove = FALSE
End Sub


Sub MainWnd_MAPPING_SelChange()
	Dim SelectedMapMode AS Long
	SelectedMapMode = getSelectedMapMode()
	
	If SelectedMapMode = SFC_MAP_SF_MENU Then
		ShowWindow(MWnd(CommandButton14), SW_SHOW)
	Else
		ShowWindow(MWnd(CommandButton14), SW_HIDE)
	End If
	
	If SelectedMapMode = SFC_MAP_ST018 Then
		ShowWindow(MWnd(CommandButton17), SW_SHOW)
	Else
		ShowWindow(MWnd(CommandButton17), SW_HIDE)
	End If
	
	
	'いじったらマニュアルチェックを付ける
	SetCheckBox(MWnd(CB_MANUAL), TRUE)
End Sub

Sub MainWnd_CheckBox1_Click()
	
End Sub

Function GetCancelKey() AS BOOL
	If (GetKeyState(VK_ESCAPE) And &H80) And (fWindowActive = TRUE) Then
		GetCancelKey = TRUE
	Else
		GetCancelKey = FALSE
	End If
End Function

Sub MainWnd_Activate(state As Integer, minimized As Integer)
	If state = WA_INACTIVE Then
		fWindowActive = FALSE
	Else
		fWindowActive = TRUE
	End If
End Sub

Sub MainWnd_CommandButton16_Click()
	SetDlgEnable(STATUS_CONNECTED)
End Sub

Sub MainWnd_ROM_SIZE_SelChange():	SetCheckBox(MWnd(CB_MANUAL),TRUE):	End Sub
Sub MainWnd_SRAM_SIZE_SelChange():	SetCheckBox(MWnd(CB_MANUAL),TRUE):	End Sub
Sub MainWnd_ROM_SIZE_EditChange():	SetCheckBox(MWnd(CB_MANUAL),TRUE):	End Sub
Sub MainWnd_SRAM_SIZE_EditChange():	SetCheckBox(MWnd(CB_MANUAL),TRUE):	End Sub
Sub MainWnd_MAPPING_EditChange():	SetCheckBox(MWnd(CB_MANUAL),TRUE):	End Sub

Function HKAC_GetWindowInt(hWnd AS HWND) AS Long
	Dim str AS BytePtr
	str=GetWndTextMalloc(hWnd)
	rcAsciiToInt(str,VarPtr(HKAC_GetWindowInt),0,TRUE)
	free(str)
End Function



Sub MainWnd_CommandButton7_Click()

	Dim data As Byte,adr As DWord
	data=GetDlgItemHex(MWnd(EditBox3)) As Byte
	adr=GetDlgItemHex(MWnd(EditBox4))
	DBM("Write 0x"+Hex$(data)+" to 0x"+Hex$(adr))
/*	WriteROM(hCOM,VarPtr(data),0,adr,1, _
			NOT(GetCheckBox(MWnd(CheckBox6))) And &H01)*/
	SetCartRegister((adr>>16) As Byte,(adr And &HFFFF) AS Word,data,	NOT(GetCheckBox(MWnd(CheckBox6))) And &H01)
	
End Sub

Const ST018_BIOS_SIZE = 160*1024 As DWord
Const ST018_BIOS_PRG_SIZE = 128*1024 As DWord
Const ST018_BIOS_DAT_SIZE =  32*1024 As DWord
Const ST018_BIOS_NAME_COMBINED = "st018.rom"
Const ST018_BIOS_NAME_PROGRAM  = "st018.program.rom"
Const ST018_BIOS_NAME_DATA	 = "st018.data.rom"
Const ST018_CHECKSUM = &HEAE5DA

Sub MainWnd_CommandButton17_Click()
	Dim out AS File
	Dim buf AS BytePtr
	Dim pPath AS BytePtr
	Dim path aS FilePath
	Dim pc AS * ProgressCallback
	
	pPath = SaveDialogCalloc(ex"ST018 ROM Image File(*.rom)\0*.rom\0Binaly Image(*.bin)\0*.bin\0すべてのファイル(*.*)\0*.*\0\0", "rom", ST018_BIOS_NAME_COMBINED)
	If pPath = NULL Then ExitSub
	path.SetPath(pPath)
	
	buf = calloc(ST018_BIOS_SIZE)
	pc = New ProgressCallback()
	
	DBMN("ST018 BIOS Dumping")
	
	'BIOSダンプ
	If ST018_BiosDump(hCOM, buf, pc) = FALSE Then
		ErrMes(hMainWnd, "st018.romの吸出しに失敗しました。", "st018.rom dumping failed.", 0)
		Goto * BIOSDUMP_EXIT
	End If
	
	Dim checksum AS DWord
	checksum = SumSnesChecksum(buf, ST018_BIOS_SIZE)
	DBM(sprintfStr(ex"CheckSum  : %08X\r\nActualSum : %08X", ST018_CHECKSUM, checksum))
	If ST018_CHECKSUM = checksum Then
		DBM(ex"Checksum OK.\r\n")
		MessageBeep(MB_ICONASTERISK)
	Else
		DBM(ex"Checksum NG.\r\nデータが破損しています。\r\nリトライしてください。\r\n")
		MessageBeep(MB_ICONHAND)
	End If
	
	'PROGRAM+DATA結合データを出力（st018.rom）
	If out.openFile(path.GetPath(), GENERIC_WRITE) = FALSE Then
		DBM("I/Oエラー")
		Goto * BIOSDUMP_EXIT
	End If
	out.write(buf, ST018_BIOS_SIZE)
	out.close()
	DBM(path.GetFileName())
	
	'st018.program.romを出力
	path.PopDir()
	path.PushFile(ST018_BIOS_NAME_PROGRAM)
	
	out.openFile(path.GetPath(), GENERIC_WRITE)
	out.write(buf, ST018_BIOS_PRG_SIZE)
	out.close()
	
	DBM(ST018_BIOS_NAME_PROGRAM)
	
	'st018.data.romを出力
	path.PopDir()
	path.PushFile(ST018_BIOS_NAME_DATA)
	
	out.openFile(path.GetPath(), GENERIC_WRITE)
	out.write(buf + ST018_BIOS_PRG_SIZE, ST018_BIOS_DAT_SIZE)
	out.close()
	DBM(ST018_BIOS_NAME_DATA)
	
	DBM(ex"saved.\r\n")
	
*BIOSDUMP_EXIT
	free(buf)
	delete pc
End Sub

' 言語仕様上抽象クラスが作りづらいので、とりあえずバリエーションはこれだけにする

Class ProgressCallback
Public
	virtual Sub Init(Max AS DWord) 
	virtual Function isCancel() As BOOL
	virtual Sub Step(step AS Long, snesReadAdr As DWord)
	virtual Sub ErrorRetry(count As DWord, limit As DWord)
	virtual Sub Final()
End Class

Type ProgressCallback_Vtable
	Init As VoidPtr
	isCancel As VoidPtr
	Step As VoidPtr
	ErrorRetry As VoidPtr
	Final As VoidPtr
End Type

Class DumpRomProgressCallBack 
	Inherits  ProgressCallback
Private
	Max AS Long
	Now AS Long
	hProgress As HANDLE
	StartTime As DWord
	ProcessTime As DWord
	Shift As Long
Public

	Sub Init(_this As VoidPtr, Max AS DWord) 
		hProgress=MWnd(hProg)
		this.Now=0
		this.Max=Max

		if Max>>10 Then	Shift = 10
		SendMessage(hProgress, PBM_SETPOS, 0, 0 )
		SendMessage(hProgress, PBM_SETRANGE,0,MAKELONG(0,(Max>>Shift) As Word))

		SetDlgEnable(STATUS_DUMPING)
		
		DBM("(Pless Esc to Cancel)")
		DBMN("Dumping")		

		StartTime = GetTickCount()
	End Sub

	Sub Step(_this As VoidPtr, step AS Long, snesReadAdr As DWord)
		SendMessage(hProgress, PBM_SETSTEP,step>>Shift,0)
		SendMessage(hProgress, PBM_STEPIT,0,0)

		Now = Now + step		
		SetWindowText(MWnd(Static7),sprintfStr("%d%%",Int(Now/Max*100)))

		DBMN(".")

		PumpMessage()
	End Sub

	Sub Final(_this As VoidPtr)
		ProcessTime = GetTickCount() - StartTime

		SendMessage(hProgress, PBM_SETPOS, 0, 0 )

		SetWindowText(MWnd(Static7),"100%")

		SetDlgEnable(STATUS_CONNECTED)

		DBMN(ex"done\r\n")
	End Sub

	Function isCancel(_this As VoidPtr) As BOOL
		PumpMessage()
		isCancel = GetCancelKey()
	End Function

	Sub ErrorRetry(_this As VoidPtr, count As DWord, limit As DWord)
		DBMN(ex"X")
	End Sub

	' ProgressCallbackの仕様外
	Function GetProcessTime() As DWord
		GetProcessTime = ProcessTime
	End Function

End Class

Function new_DumpRomProgressCallBack() As *DumpRomProgressCallBack
	Dim ret As *DumpRomProgressCallBack, vtable As *ProgressCallback_Vtable
	ret = new DumpRomProgressCallBack
'	vtable = calloc(sizeof(ProgressCallback_Vtable))
'	vtable = calloc(sizeof(ProgressCallback_Vtable))
'	Dim vtptr AS *ProgressCallback_Vtable
'	vtptr = GetDWord(ret)
'	SetDWord(ret, vtable)
	vtable = GetDWord(ret)
	vtable->Init 		= AddressOf(ret->Init)
	vtable->isCancel 	= AddressOf(ret->isCancel)
	vtable->Step 		= AddressOf(ret->Step)
	vtable->ErrorRetry 	= AddressOf(ret->ErrorRetry)
	vtable->Final 		= AddressOf(ret->Final)
	new_DumpRomProgressCallBack = ret 
End Function

Sub delete_DumpRomProgressCallBack(pc As *DumpRomProgressCallBack)
'	free(GetDWord(pc) As DWord)
	delete pc
End Sub

Class SramProgressCallBack 
	Inherits  ProgressCallback
Private
	Max AS Long
	Now AS Long
	hProgress As HANDLE
Public

	Sub Init(_this As VoidPtr, Max AS DWord) 
		hProgress=MWnd(hProg)
		this.Now=0
		this.Max=Max

		SendMessage(hProgress, PBM_SETPOS, 0, 0 )
		SendMessage(hProgress, PBM_SETRANGE,0,MAKELONG(0,(Max) As Word))

		SetDlgEnable(STATUS_DUMPING)
		
		DBM("Dumping...")		
	End Sub

	Sub Step(_this As VoidPtr, step AS Long, snesReadAdr As DWord)
		SendMessage(hProgress, PBM_SETSTEP,step,0)
		SendMessage(hProgress, PBM_STEPIT,0,0)

		Now = Now + step		
		SetWindowText(MWnd(Static7),sprintfStr("%d%%",Int(Now/Max*100)))

		DBM(sprintfStr("SRAM %02X:%04X +%04X", snesReadAdr>>16, snesReadAdr And &HFFFF, step))

		PumpMessage()
	End Sub

	Sub Final(_this As VoidPtr, )
		SendMessage(hProgress, PBM_SETPOS, 0, 0 )

		SetWindowText(MWnd(Static7),"100%")

		SetDlgEnable(STATUS_CONNECTED)

	End Sub

	Function isCancel(_this As VoidPtr) As BOOL
		PumpMessage()
		isCancel = GetCancelKey()
	End Function

	Sub ErrorRetry(_this As VoidPtr, count As DWord, limit As DWord)
		DBMN(ex"X")
	End Sub


End Class

Function new_SramProgressCallBack() As *SramProgressCallBack
	Dim ret As *SramProgressCallBack, vtable As *ProgressCallback_Vtable
	ret = new SramProgressCallBack
'	vtable = calloc(sizeof(ProgressCallback_Vtable))
'	SetDWord(ret, vtable)

	vtable = GetDWord(ret)
	vtable->Init 		= AddressOf(ret->Init)
	vtable->isCancel 	= AddressOf(ret->isCancel)
	vtable->Step 		= AddressOf(ret->Step)
	vtable->ErrorRetry 	= AddressOf(ret->ErrorRetry)
	vtable->Final 		= AddressOf(ret->Final)
	new_SramProgressCallBack = ret 
End Function

Sub delete_SramProgressCallBack(pc As *SramProgressCallBack)
'	free(GetDWord(pc) As DWord)
	delete pc
End Sub

Sub MainWnd_CommandButton18_Click()   

		SetCPU_Clock(hCOM, HKAC_CLOCK_CPU_OVERCLOCKED) 'Enable CPU Clock for Writing SA-1 Register
End Sub

Function DumpFullROM(info As * SFC_CART_INFO, Path As BytePtr) As Long
	Dim mmapModel AS SFC_MMAP_MODEL, pc AS *DumpRomProgressCallBack
	Dim outFile AS File

	if outFile.openFile(Path, GENERIC_WRITE) = FALSE Then
		DBM("File open error")
		ExitFunction
	End If

	GetMmapModel(info, FALSE, VarPtr(mmapModel))
	pc = new_DumpRomProgressCallBack()

	Dim rom as BytePtr
	rom = calloc( info->RomSize )
	FillMemory(rom, info->RomSize, &HDD)
	
	Dim ret AS Long
	ret = DumpRom2(hCOM, info, VarPtr(mmapModel), rom, pc)
	outFile.write(rom, info->RomSize)	

	Dim time AS DWord
	time = pc->GetProcessTime()
	DBMf(ex"Time  : %d.%d sec", (time/1000) As Long, time Mod 1000)

	if ret = HKAC_DUMPROM_OK Then
		Dim speed As DWord
		speed = (info->RomSize / (time / 1000)) As DWord
		if speed > 999 Then
			DBMf(ex"Speed : %d,%03d byte/sec", (speed/1000) As DWord, speed Mod 1000)
		Else
			DBMf(ex"Speed : %d byte/sec", speed)
		End If

		Dim actualSum AS Word
		actualSum = CalcSnesChecksum(info, rom)
		DBMf("HeaderSum: %02X, %02X", info->CheckSum2, info->CheckSum1)
		DBMf("ActualSum: %02X, %02X", actualSum And &HFFFF, NOT(actualSum) And &HFFFF)

		if info->enableChecksum Then
			if CheckChecksum(info, actualSum) Then
				DBM(ex"checksum OK.")
			Else
				DBM(ex"checksum NG...!!!")
				MessageBoxf(hMainWnd, "ROM Dump Error", MB_ICONERROR, _
							ex"Checksum Error!\nFailed to dump ROM.\nChecksum1 : %04X -> %04X\nChecksum2 : %04X -> %04X", info->CheckSum1, (not(actualSum) And &HFFFF), info->CheckSum2, (actualSum And &HFFFF))
			End If
		Else
			DBM("checksum is disabled.")
		End if

	Else if ret = HKAC_DUMPROM_USER_CANCEL Then
		DBM("Canceled by user.")

	Else 
		DBM("Failed to dump ROM")
	End If

	DBMN(ex"\r\n")

	outFile.close()
	free(rom)
	delete_DumpRomProgressCallBack(pc)

	DumpFullROM = ret
End Function
