'RGBA_CRT's Libs
#include "RGBADef.sbp"
#include "EasyIO.sbp"
/*  Todo : 
		HTTP系をクラスに
*/

Sub PumpMessage() 
	Dim msg As MSG
 	while PeekMessage( msg, NULL, 0, 0, PM_REMOVE ) 
    TranslateMessage( msg )
    DispatchMessage( msg )
  	Wend
EndSub

Function GetDlgItemHex(hWnd AS HWND) AS Long
	Dim buf as BytePtr
	buf=calloc(GetWindowTextLength(hWnd)+5)
	GetWindowText(hWnd,buf,GetWindowTextLength(hWnd)+1)
	Dim i as Long,mode as Long
	Do
		if buf[i]=&H20 Then 
			i++
			Continue'Skip Space
		Elseif buf[i]=&H30 Then	'0'
			if buf[i+1]=&H78 Or buf[i+1]=&H58 Then	'x'
				'16進決定,0xを&Hに変更
				buf[i]=&H26:	buf[i+1]=&H48
			endif
		endif
		ExitDo		
	Loop
	GetDlgItemHex=Val(buf+i) AS Long
	free(buf)
EndFunction

'エラーメッセージ表示
Function ErrMes(hOwner AS HWND,Text As BytePtr,Title As BytePtr,Flag As Dword) As Long
	SetForegroundWindow(hOwner)
	MessageBeep(MB_ICONHAND)
	ErrMes=MessageBox(hOwner,Text,ProgramName+" - "+MakeStr(Title),MB_ICONERROR Or Flag)
EndFunction

'コンソールのウィンドウハンドルを取得
Function GetConsoleWndHandle() AS HANDLE
	dim hConsole As HWND
	SetConsoleTitle("_FIND_STRING_RGBA_CRT_") 
	Sleep(40) 
	hConsole=FindWindow(NULL, "_FIND_STRING_RGBA_CRT_")
EndFunction

'コンソールのアイコンを変更
Sub SetConsoleIcon()
	SendMessage(GetConsoleWndHandle(),WM_SETICON,ICON_SMALL,LoadImage(GetModuleHandle(0),IDI_ICON1 As BytePtr,IMAGE_ICON,GetSystemMetrics(SM_CXSMICON),GetSystemMetrics(SM_CYSMICON),LR_DEFAULTCOLOR) As Long)
EndSub

Sub printf(lpFormat As BytePtr)(a As DWord ,b As DWord ,c As DWord ,d As DWord ,e As DWord ,f As DWord ,g As DWord ,h As DWord ,i As DWord ,j As DWord ,k As DWord ,l As DWord ,m As DWord ,n As DWord )
	Dim Buf AS BytePtr,ret AS Long,Ptr[13] AS DWord
	Buf=calloc(lstrlen(lpFormat)+1024*4)
	if Buf=0 Then MessageBox(0,ex"RGBALib - Line 37\nメモリ確保に失敗しました。",0,0)
	Ptr[0]=a:	Ptr[1]=b:	Ptr[2]=c:	Ptr[3]=d:	Ptr[4]=e:	Ptr[5]=f:	Ptr[6]=g:	Ptr[7]=h:	Ptr[8]=i:	Ptr[9]=j:	Ptr[10]=k:		Ptr[11]=l:		Ptr[12]=m:		Ptr[13]=n:	
	ret=wsprintf(Buf,lpFormat,a,b,c,d,e,f,g,h,i,j,k,l,m,n)
'	Print MakeStr(Buf);
	PrintPtr(Buf,ret)
	free(Buf)	
EndSub

Sub StringArrayViewer(Data As *Byte)
	dim i as long
	dim L as long
	Dim Tx[2] As Byte
	dim TB As byte

	L=lstrlen(Data)

	Print "Base Adress : 0x"+Hex$(Data)
	Print "Bytes       : "+Str$(L)+"Byte"
	Print ex"\nText : ";

	For i = 0 to L-1
		if TB <> 0 then
			Print "["+Chr$(TB)+Chr$(Data[i])+"] ";
			TB=0
			i++
		Endif

		if Data[i]=0 then ExitFor

		if Data[i] >= 128 then
			SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE),2)
			Print " [>] ";
			SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE),1 Or 2 Or 4)
			TB=Data[i]
		else
			Print " ["+Chr$(Data[i])+"] ";
			TB=0
		endif
	Next i

	Print ex"\nData : ";

	For i = 0 to L-1
		wsprintf(Tx,"%02X",Data[i])
		Print "["+MakeStr(Tx)+"] ";
	Next i

	Print ex"\nN[i] : ";

	For i = 0 to L-1
		wsprintf(Tx,"%02d",i)
		Print "["+MakeStr(Tx)+"] ";
	Next i

	Print ex"\n"
Endsub

'BASE ADRESS:0x54546E
' [T]  [E]  [S]
'[14] [15] [16]
'Point
Type WaveInfo
	RIFF As RIFF_HEADER
	fmt As FMT_CHUNK
	Data As DATA_CHUNK
	WaveAddr As DWORD
	EndOfWave As Dword
	PlayTime As Dword
EndType
Type RIFF_HEADER
	RIFF As DWord
	Size As DWord
	RType AS DWord
EndType
Type FMT_CHUNK
	fmt  As DWORD
	Size As DWORD
	FormatCode As WORD
	ch As WORD
	Sample As DWORD
	SecByte As DWORD
	Block As WORD
	Bit As WORD
EndType
Type DATA_CHUNK
	DATA As DWORD
	DataSize As DWORD
EndType


Class TrayIconManager
	pNotIfyIconData As NOTIFYICONDATA	'タスクトレイ
public
	hIcon[6] As HANDLE'IconID
	Bitter As Byte
	Flash[2] As Long
	isAdded As Byte

	'初期化時
	Sub TrayIconManager()
		Dim i As Long
		For i = 1 To 6
  			hIcon[i] = 
		Next i
		RestreMsg =RegisterWindowMessage("TaskbarCreated")'タスクバーの再起動対策
	EndSub
	'破棄時
	Sub ~TrayIconManager()
		Dim i As Long
		For i = 1 To 6
  			DeleteObject(hIcon[i])
		Next i
	EndSub
	'登録削除
	Sub Del()
		Shell_NotifyIcon(NIM_DELETE ,pNotIfyIconData) '切り替え
		If Flash[0]<>0 then	KillTimer(hDummy,&HFF6)
	EndSub
	'登録
	Function Add(IconID As Long,Title As BytePtr)
	'	If isAdded=1 then ExitFunction
		Dim nRC As Long, i As Byte

	    'NOTIfYICONDATA構造体を設定
		If lstrlen(Title) < 64 then
	  		lstrcpy(pNotIfyIconData.szTip ,Title)
		Else
			memcpy(pNotIfyIconData.szTip,Title,63)
			pNotIfyIconData.szTip[63]=0
		EndIf
	    pNotIfyIconData.uFlags = NIF_ICON Or NIF_TIP Or NIF_MESSAGE
	    pNotIfyIconData.uID = TaskID
	    pNotIfyIconData.cbSize = SizeOf(NOTIfYICONDATA)'Len(pNotIfyIconData)
	    pNotIfyIconData.hWnd = hDummy
	    pNotIfyIconData.uCallbackMessage = MWM_TASK

	    pNotIfyIconData.hIcon = LoadImage(GetModuleHandle(0),IconID As *Byte,IMAGE_ICON,GetSystemMetrics(SM_CXSMICON),GetSystemMetrics(SM_CYSMICON), LR_SHARED ) As DWORD

	*RETRY
		nRC = Shell_NotifyIcon(NIM_ADD ,pNotIfyIconData) '切り替え
		If nRC=FALSE Then
			DBM("Error: cannot regist tasktray")
			i++
			If i=5 then Add=FALSE:ExitFunction
			Sleep(50)
			Goto *RETRY
		EndIf
		isAdded=TRUE
		Add=TRUE
	EndFunction
	'タイトルチェンジ
	Sub UpdateTitle(Title As BytePtr)
		If lstrlen(Title) < 64 then
	  		lstrcpy(pNotIfyIconData.szTip ,Title)
		Else
			memcpy(pNotIfyIconData.szTip,Title,63)
			pNotIfyIconData.szTip[60]=&H2E
			pNotIfyIconData.szTip[61]=&H2E
			pNotIfyIconData.szTip[62]=&H2E
			pNotIfyIconData.szTip[63]=0
		EndIf
		Shell_NotifyIcon(NIM_MODIFY, pNotIfyIconData) '切り替え
	EndSub
	Sub UpdateIcon(IconID As Long)
		If Flash[0]<>0 then	KillTimer(hDummy,&HFF6)
	    pNotIfyIconData.hIcon =LoadImage(GetModuleHandle(0),IconID As *Byte,IMAGE_ICON,GetSystemMetrics(SM_CXSMICON),GetSystemMetrics(SM_CYSMICON), LR_SHARED ) As DWORD
		Shell_NotifyIcon(NIM_MODIFY, pNotIfyIconData) '切り替え
	EndSub
	Function GetIconHandle(IconID As Long) As Long
		GetIconHandle=hIcon[IconID-100] As Long
	EndFunction
	Function ShowInfo(Title As BytePtr , Info As BytePtr,Icon AS DWORD,TimeOut AS DWORD)  As Long
	    pNotIfyIconData.uFlags = NIF_INFO OR NIF_MESSAGE
		lstrcpy(pNotIfyIconData.szInfoTitle, Title)
		lstrcpy(pNotIfyIconData.szInfo,Info)
		pNotIfyIconData.dwInfoFlags = Icon
		pNotIfyIconData.uTimeout=TimeOut
		 ShowInfo=Shell_NotifyIcon(NIM_MODIFY, pNotIfyIconData)
		pNotIfyIconData.uFlags = NIF_ICON Or NIF_TIP Or NIF_MESSAGE
	EndFunction
	Sub _UpdateIcon2(IconID As Long)
	    pNotIfyIconData.hIcon =LoadImage(GetModuleHandle(0),IconID As *Byte,IMAGE_ICON,GetSystemMetrics(SM_CXSMICON),GetSystemMetrics(SM_CYSMICON), LR_SHARED ) As DWORD
		Shell_NotifyIcon(NIM_MODIFY, pNotIfyIconData) '切り替え
	EndSub
End Class

Sub PrintPtr(Text As BytePtr)(Length AS Long)
	if Length=0 then Length=lstrlen(Text)		
	WriteFile(GetStdHandle(STD_OUTPUT_HANDLE),Text,Length,NULL,ByVal NULL)
Endsub

Function FillString(Text As BytePtr,Buf As BytePtr,Num As DWord ,Max As DWord) As DWord
	Dim i As DWord/*,tSize As DWord*/,ti As DWord,nMake As DWord
'	tSize=lstrlen(Text)
	Do
		If i=>Max-1 OR nMake>=Num  then ExitDo
		Buf[i]=Text[ti]
		i++
		ti++
		If Text[ti]=0 then ti=0:nMake++
	Loop
	Buf[i]=0
	Buf[Max-1]=0
	FillString=i
EndFunction

Sub pstrcat(To As BytePtr,Src As BytePtr ,ByRef Ptr As DWORD)(Size As DWORD)
     If Size = 0 then Size=lstrlen(Src)
     memcpy(To+Ptr,Src,Size)
	'(free(Src)
     Ptr += Size
endsub

Function RunAndGetExitCode(App As BytePtr,CmdLine As BytePtr) AS Long
	Dim si AS STARTUPINFO 
	Dim pi As PROCESS_INFORMATION
	Dim Child As HANDLE
	Dim r As DWORD

	if CreateProcess(App,CmdLine,ByVal NULL,ByVal NULL,FALSE,CREATE_NEW_CONSOLE,NULL,NULL,si,pi)=FALSE Then'CREATE_NEW_CONSOLE を 0にすれば非表示
		'CreateProcess Error
		RunAndGetExitCode=-1
		ExitFunction
	endif

	' 子プロセス起動成功
	Child = pi.hProcess

	' 不要なスレッドハンドルをクローズする
	CloseHandle(pi.hThread)

	' 子プロセスの終了待ち
	r = WaitForSingleObject(Child, INFINITE)
	if r<>WAIT_OBJECT_0 then
		'wait error!
		RunAndGetExitCode=-1
		ExitFunction
	endif

	' 子プロセスの終了コードを取得
	Dim exitCode As DWORD
	if GetExitCodeProcess(Child, exitCode)=FALSE then
		RunAndGetExitCode=-1
		ExitFunction
	endif

	if Child<>0 then CloseHandle(Child)
	RunAndGetExitCode=exitCode
Endfunction

Function GetHttpStatusText(HttpStatusNo As Long)
Dim STATES AS BytePtr

'出典：http://www.tohoho-web.com/ex/http.htm
Select Case HttpStatusNo
	Case 100 : STATES="[Continue] 処理を継続しています。続きのリクエストを送信してください。"
	Case 101 : STATES="[Switching Protocols Upgrade] ヘッダで指定したプロトコルに変更して再要求してください。"
	Case 200 : STATES="[OK] 成功しました！"
	Case 201 : STATES="[Created Location] ヘッダで指定した場所に新しいコンテンツが作成されました。"
	Case 202 : STATES="[Accepted] 要求は受理されました。ただし処理は完了していません。"
	Case 203 : STATES="[Non-Authoritative Information] 応答ヘッダはオリジナルサーバーが返したものとは異なりますが、処理は成功です。"
	Case 204 : STATES="[No Content] コンテンツはありませんが、処理は成功しました。"
	Case 205 : STATES="[Reset Content] 要求を受理したので、現在のコンテンツ（画面）を破棄してください。"
	Case 206 : STATES="[Partial Content] コンテンツを一部のみ返却します。"
	Case 300 : STATES="[Multiple Choices] コンテンツ入手方法について複数の選択肢があります。"
	Case 301 : STATES="[Moved Permanently Location ] ヘッダで指定された別の場所に移動しました。"
	Case 302 : STATES="[Found	Location] ヘッダで指定された別の場所に見つかりました。そちらを見てください。"
	Case 303 : STATES="[See Other Location] ヘッダで指定された他の場所を見てください。"
	Case 304 : STATES="[Not Modified] 更新されていません。If-Modified-Since ヘッダを用いた場合に返却されます。"
	Case 305 : STATES="[Use Proxy] Location ヘッダで指定したプロキシを使用してください。"
	Case 306 : STATES="[Unused] 未使用のステータスが帰ってきました。きっと未来のサーバー。"
	Case 307 : STATES="[Temporary Redirect] 別の場所に一時的に移動しています。"
	Case 400 : STATES="[Bad Request] 要求が不正です。 > 大体こっち側のバグ"
	Case 401 : STATES="[Unauthorized] 認証されてません。"
	Case 402 : STATES="[Payment Required] 支払いが必要です。"
	Case 403 : STATES="[Forbidden] アクセスが認められていません。"
	Case 404 : STATES="[404 Not Found] ファイルが見つかりません。"
	Case 405 : STATES="[Method Not Allowed] 指定したメソッドはサポートされていません。"
	Case 406 : STATES="[Not Acceptable] 許可されていません。"
	Case 407 : STATES="[Proxy Authentication Required] リクエストがタイムアウトしました。"
	Case 408 : STATES="[Request Timeout] リクエストがタイムアウトしました。"
	Case 409 : STATES="[Conflict] リクエストがコンフリクト（衝突・矛盾）しました。"
	Case 410 : STATES="[Gone] 要求されたコンテンツは無くなってしまいました"
	Case 411 : STATES="[Length Required] Content-Length ヘッダを付加して要求してください。"
	Case 412 : STATES="[Precondition Failed] If-... ヘッダで指定された条件に合致しませんでした。"
	Case 413 : STATES="[Request Entity Too Large]	要求されたエンティティが大きすぎます。"
	Case 414 : STATES="[Request-URI Too Long] 要求された URI が長すぎます。"
	Case 415 : STATES="[Unsupported Media Type] サポートされていないメディアタイプです。"
	Case 416 : STATES="[Requested Range Not Satisfiable] 要求されたレンジが不正です。"
	Case 417 : STATES="[Expectation Failed	Expect] ヘッダで指定された拡張要求は失敗しました。"
	Case 500 : STATES="[Internal Server Error]	サーバーで予期しないエラーが発生しました。"
	Case 501 : STATES="[Not Implemented] 指定されたHTTPメゾッドは実装されていません。"
	Case 502 : STATES="[Bad Gateway] ゲートウェイが不正です。"
	Case 503 : STATES="[Service Unavailable] サービスは利用可能ではありません。"
	Case 504 : STATES="[Gateway Timeout] ゲートウェイがタイムアウトしました。"
	Case 505 : STATES="[HTTP Version Not Supported] このHTTPバージョンはサポートされていません。"
	Case -1 : GetHttpStatusText="[ERROR] このプログラム側でのエラーが発生しました。" : ExitSub
	Case Else : STATES="[UNKNOW] 未知のステータス番号です。"
EndSelect

GetHttpStatusText=STATES

End Function

Function Lit2Big(Data As Word) As Dword
	Dim big[4] As Byte,In[3] As Byte
	memcpy(In,VarPtr(Data),2)
/*	big[0]=In[3]
	big[1]=In[2]
	big[2]=In[1]
	big[3]=In[0]*/
	big[0]=In[1]
	big[1]=In[0]
	memcpy(VarPtr(Lit2Big),big,2)
EndFunction
Function Str2Dw(Data As BytePtr) As DWORD
	memcpy(VarPtr(Str2Dw),Data,4)
endfunction

Function Dw2Str(Data As DWORD) As String
	Dim Str[4] As Byte
	memcpy(Str,VarPtr(Data),4)
	Str[4]=0
	Dw2Str=MakeStr(Str)
EndFunction

'InStrのバイナリ版
Function InByteBin(Data As BytePtr,Size As DWORD,Bytes As Byte)(Jump AS Long) As Long
	Dim i As DWORD,tmp As Byte
	if Jump<>0 then i=Jump
	Do
		if Data[i]=Bytes Then InByteBin=i: ExitDo
		i++
		if i => Size then InByteBin=-1: ExitDo
	Loop
EndFunction

'ID3をスキップして最初のフレームのアドレスを取得する関数
Function JumpID3(hFile AS HANDLE) As Long
	Dim dwAB AS DWORD
	Dim Tmp As DWORD
	Dim i As Long
	Dim nT[4] As Byte
	Dim SavedFP AS DWORD '呼び出し前のファイルポインタ
	'今のファイルポインタを保存してファイルの先頭へジャンプ
	SavedFP = GetFilePointer(hFile)
	SetFilePointer(hFile,0,0,FILE_BEGIN)

*CHK_ID3
	'ファイルを3バイト読んでID3があったらID3v2なのでスキップ（スキップした先にまたID3がある極悪非道なMP3がある）
	If ReadFile(hFile,VarPtr(Tmp),3,VarPtr(dwAB),ByVal NULL) = FALSE then Goto *Err	'ファイル戦闘ロード
	If lstrcmp(VarPtr(Tmp),"ID3") = 0 then
		'ID3のサイズが記録されているところまで飛ぶ
		SetFilePointer(hFile,3,0,FILE_CURRENT)
		If ReadFile(hFile,nT,4,VarPtr(dwAB),ByVal NULL) = FALSE then Goto *Err
		'ID3サイズ計算
		SetFilePointer(hFile, (nT[0]*2^21+nT[1]*2^14+nT[2]*2^7+nT[3]) As Long ,0,FILE_CURRENT)
		'Jump FrameHeader
		Goto *CHK_ID3	
	Else
		'読み込んだ3バイト分戻る
		SetFilePointer(hFile,-3,0,FILE_CURRENT)
		'フレームヘッダの開始アドレスを記録
		JumpID3=SetFilePointer(hFile,0,0,FILE_CURRENT)	
	EndIf

	'フレームヘッダを検索
	FillMemory(nT,4,0)	'nTの初期化
	If ReadFile(hFile,nT,4,VarPtr(dwAB),ByVal NULL) = FALSE then Goto *Err

	'フレーム同期　1111 1111 111x xxxx = FFE0〜
	If nT[0]=&HFF And nT[1]=>&HE0 then 
		''DBM(ex"Frame Header Found."
	Else
		''DBM("Frame Herader Not Found. This is not MP3 File."
		'ファイル50KB読み込んでFFを探せばいい
		Const ShSize = 1024*50
		''DBM("   [ﾌﾚｰﾑｻｰﾁﾓｰﾄﾞ]     ファイル形式怪しいです")
		FrameAdr=0
		Dim ret As Long
		Tmp=calloc2(ShSize) As DWORD
		'SetFilePointer(hFile,0,0,FILE_BEGIN)
		LoadFile(hFile,Tmp As BytePtr,ShSize)
		Do
			ret=InByteBin(Tmp As BytePtr,ShSize,&HFF,ret+1)
			'''DBM("HIT:0x"+Hex$(GetFilePointer(hFile)-ShSize+ret))
			memcpy(nT,(Tmp+ret) As VoidPtr,4)
			If nT[0]=&HFF And nT[1]=>&HE0 then 
				JumpID3=(GetFilePointer(hFile)-ShSize+ret) As Long
				Exitdo
			endif
			if ret = -1 then Goto *Err
		Loop	
		free2(Tmp As VoidPtr)
	EndIf
	'MP3Info.StartAdr=JumpID3
	'ファイルポインタを戻す
	SetFilePointer(hFile,SavedFP,0,FILE_BEGIN)
	ExitFunction

	'エラー処理エリア
*Err
	JumpID3=-1
EndFunction



'BM法文字列サーチ（指定文字列内に特定の文字列があるか？＝True or false）
Function SerchTextLine(Src As BytePtr,Text As BytePtr,sLen As DWORD,isFirst As DWORD) As Byte
	Dim Skip[255] As DWORD
	Dim tLen As DWORD'(,sLen As DWORD
	Dim i As DWORD,j As Long,k As Long
	Dim letSkip As Byte, letLast As Byte
	Dim SP AS Long
	tLen=lstrlen(Text)
	if tLen=0 then 	SerchTextLine=FALSE:	ExitFunction
	For i=0 To 255 : Skip[i]=tLen :	Next i
	For i=0 To tLen-1 
		Skip[Text[i]]=tLen-1-i 
		if Skip[Text[i]]=0 then Skip[Text[i]]=1
	Next i
	tLen--
	letLast=Text[tLen]
	For i=tLen To sLen Step Skip[letSkip]
		letSkip=Src[i]
		if letSkip=letLast Then 
			j=i-1
			k=tLen-1
			While Src[j]=Text[k]
				if k=0 then 
					Goto *FOUND
				Endif
				j--
				k--
			Wend
		Endif
	Next i
	SerchTextLine=FALSE
	ExitFunction
*FOUND
	Dim Line As BytePtr
	Dim EP As Long
	'SP=j-InStrByteRev(Src,&H0A,j,&H0D)
	SerchTextLine=TRUE
*RETRY
	if Src[j-SP]= &H0A Or Src[j-SP]=&H0D Then if isFirst<>0 then SP--: Goto *RETRY
	EP=InStrByte(Src+j,&H0D,sLen)'+j
'	Print Chr$(Src[j-SP])+"["+Hex$(Src[j-SP])+"]"
'	Print Chr$(Src[j-SP+1])+"["+Hex$(Src[j-SP+1])+"]"
	if EP=0 then EP=sLen
	if EP-SP<=1 then ExitFunction
/*	Line=calloc(EP+SP)
	memcpy(Line,Src+j-SP,EP+SP)
	Line[EP+SP]=0
	ListText2.AddStr(Line)
	SerchTextLine=j+EP*/
EndFunction

Function InStrByte(Data As BytePtr,Serch As Byte,DataSize As DWORD) As Long
	Dim i as DWORD,si As Dword, sLen As Long
	'Dim tmp1 As Byte,tmp2 As Byte
	'sLen=lstrlen(Serch)
	Do
		if Data[i]=Serch then
			InStrByte=i	
			'debug
			ExitDo
		'	i++
		endif
		if i=DataSize then
			InStrByte=-1
			ExitFunction
		endif
		i++
	Loop
endfunction

'引数をNULLで区切る。NULL NULLで終わり (例）コマンド\0引数１\0"引数2"\0\0
Function MakeCmdLine(Text As BytePtr) as BytePtr
	Dim i AS DWORD,fDQ AS Byte,SP=-1 AS Long'-1でセット待ち
	dim dbg AS Byte
	dim  Buf As BytePtr,bi AS DWORD
	Const SPR=&H00'区切り文字NULL

	If Text=0 then ExitFunction
	Buf=calloc(lstrlen(Text)+4)
	
	For i = 0 To lstrlen(Text)
			If SP=-1 then
				If Text[i]<>&H20 then
					SP=i
					dbg=1
				Else
					Continue
				EndIf
			EndIf

			If fDQ=0 then
				If Text[i]=&H20 then
					memcpy(Buf+bi,Text+SP,i-SP)
					bi+=(i-SP)+1
					Buf[bi-1]=SPR
					SP=-1
				ElseIf Text[i]=0 then
					memcpy(Buf+bi,Text+SP,i-SP)
					bi+=(i-SP)+1
					Buf[bi-1]=SPR
				elseIf Text[i]=&H22 then'Doubleクォーテート
					fDQ=Not(fDQ)
				Else
			EndIf
			dbg=0
		Else
			If Text[i]=&H22 then'Doubleクォーテート
				fDQ=Not(fDQ)
			Else
			EndIf
		EndIf
	Next i
	Buf[bi]=0
	Buf[bi+1]=0
	MakeCmdLine=Buf
Endfunction

'↑で作られた文字列を扱う関数
'↑はNULLで区切られているので、lstrcpyみたいな関数が使える。
'この関数は指定した番号の引数をとってくる。
'EX) Text=cmd1\0cmd2\0opt1\0"path"\0\0
'2を指定すれば3つ目の「opt1」の開始アドレス0xAが返ってくる。MakeStr(Text+0xA)で「opt1」という文字列を取り出せる。
Function GetCmdAdr(Text AS BytePtr,Num As Byte) AS DWORD
	Dim i As DWORD,C As Byte
	If Num=0 then GetCmdAdr=0:ExitFunction
	Do
		If Text[i]=0 then
			If Text[i+1]=0 then GetCmdAdr=-1:ExitDo'ダブルNULL＝END
			C++
			If C=Num then GetCmdAdr=i+1:ExitDo
		EndIf
		i++
	Loop
Endfunction

'ダブルクォーテート抜き
'(戻り値はFreeしなければならない)
Function DelDQ(Text As *Byte) As *Byte
	dim SP as Long
	dim EP As Long
	dim i as long
		If Text=0 then ExitFunction
	SP=1
	EP=lstrlen(Text)-2
	Do
		If Text[i] = Asc(ex"\q") then
			SP = i + 1
			exitdo
		EndIf
			If i >= lstrlen(Text) then
			SP = 0
			ExitDo
		EndIf
		i++
	Loop
	i=0
	Do
		If Text[lstrlen(Text)-i] = Asc(ex"\q") then
			EP = lstrlen(Text)-i 
			exitdo
		EndIf
		If i >= lstrlen(Text) then
			EP = lstrlen(Text)
			ExitDo
		EndIf
		i++
	Loop
	If EP <= 0 then EP=lstrlen(Text)

	DelDQ=calloc(lstrlen(Text)+2)
	memcpy(DelDQ,Text+SP,EP)
	DelDQ[EP-SP]=0
EndFunction

'ファイルパスが正しいかチェック
Function IsFilePath(FilePath AS BytePtr) As Byte
	Dim hFile AS HANDLE
	hFile=CreateFile(FilePath,GENERIC_READ,FILE_SHARE_READ OR FILE_SHARE_WRITE,ByVal NULL,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL)
	If hFile=INVALID_HANDLE_VALUE Then
		IsFilePath=FALSE
	Else
		IsFilePath=TRUE
		CloseHandle(hFile)
	EndIf
EndFunction

Type WaveHead
	RIFF As DWord
	rSize As DWord
	RType AS DWord
	fmt  As DWORD
	fSize As DWORD
	FormatCode As WORD
	ch As WORD
	Sample As DWORD
	SecByte As DWORD
	Block As WORD
	Bit As WORD
	DATA As DWORD
	DataSize As DWORD
EndType

Sub InitWaveHeader(ByRef Head As WaveHead)
	With Head
	.RIFF=Str2Dw("RIFF")
	.RType=Str2Dw("WAVE")
	.rSize=0
	.Bit=16
	.ch=2
	.fmt=Str2Dw("fmt ")
	.FormatCode=1
	.Sample=48000
	.fSize=16
	.Block=4
	.SecByte=.ch*2*.Sample
	.DATA=Str2Dw("data")
	.DataSize=4
	Endwith
endsub

Function win_strcmpi(str1 AS BytePtr,str2 AS BytePtr,Length AS DWord) AS BOOL
	if CompareString(LOCALE_SYSTEM_DEFAULT,NORM_IGNORECASE,str1,Length,str2,Length) = CSTR_EQUAL Then
		win_strcmpi=TRUE
	Else
		win_strcmpi=FALSE
	endif
EndFunction

Function win_strcmp(str1 AS BytePtr,str2 AS BytePtr,Length AS DWord) AS BOOL
	if CompareString(LOCALE_SYSTEM_DEFAULT,0,str1,Length,str2,Length) = CSTR_EQUAL Then
		win_strcmp=TRUE
	Else
		win_strcmp=FALSE
	endif
EndFunction


Function Dump(Data As BytePtr,Size As DWORD)(VAdr As DWORD,ShowHeader AS BOOL) AS DWORD
	Dim Tmp[&H20] As Byte,i As Long,Adr As DWORD
	
	SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), BACKGROUND_BLUE OR BACKGROUND_GREEN OR BACKGROUND_RED)
	if VAdr=0 Or ShowHeader=TRUE then Print " ADDRESS  00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F  0123456789ABCDEF "
	SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 1 OR 2 OR 3 OR 4)
	Do
		SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), BACKGROUND_BLUE  OR 4 OR 3 )
		wsprintf(Tmp,"%08X ",Adr+VAdr)
		Print MakeStr(Tmp);
		SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 1 OR 2 OR 3 OR 4)
		Print " ";
		For i=0 To &H0F
			if Adr+i=>Size then
				wsprintf(Tmp,"-- ",0)
			Else 
				wsprintf(Tmp,"%02X ",Data[Adr+i])
			endif
			Print MakeStr(Tmp);
		Next i
		Print " ";
		For i=0 To &H0F
			if Adr+i=>Size then Goto *EXIT_LOOP
			if Data[Adr+i]<&H20 then 
				Print ".";
			Else
				Print Chr$(Data[Adr+i]);
			Endif
		Next i
		i=0
		Adr+=&H10
		if Adr+i=>Size then Goto *EXIT_LOOP
		Print
	Loop
*EXIT_LOOP
'	Print
'	Print Hex$(Adr*&H10+i)+"="+Hex$(Size)
	Dump=Adr
Endfunction